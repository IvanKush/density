<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>density: heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt;::reentrant_put_transaction&lt; ELEMENT_COMPLETE_TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">density
   </div>
   <div id="projectbrief">C++11 library for paged memory management, function queues, heterogeneous queues and lifo memory management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedensity.html">density</a></li><li class="navelem"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a></li><li class="navelem"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdensity_1_1heter__queue_1_1reentrant__put__transaction-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt;::reentrant_put_transaction&lt; ELEMENT_COMPLETE_TYPE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="heter__queue_8h_source.html">heter_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aade140513e6d5591cc641434959da925"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#aade140513e6d5591cc641434959da925">reentrant_put_transaction</a> () noexcept</td></tr>
<tr class="separator:aade140513e6d5591cc641434959da925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad64aa5379a0a3b847080856ed5045fb2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#ad64aa5379a0a3b847080856ed5045fb2">reentrant_put_transaction</a> (const <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> &amp;)=delete</td></tr>
<tr class="separator:ad64aa5379a0a3b847080856ed5045fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25890d943db83f10acbbac0b2fc3a0ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a25890d943db83f10acbbac0b2fc3a0ca">operator=</a> (const <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> &amp;)=delete</td></tr>
<tr class="separator:a25890d943db83f10acbbac0b2fc3a0ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017cf293f011a2315f3df2aebce86880"><td class="memTemplParams" colspan="2">template&lt;typename OTHERTYPE , typename  = typename std::enable_if&lt;                std::is_same&lt;OTHERTYPE, ELEMENT_COMPLETE_TYPE&gt;::value ||                std::is_void&lt;ELEMENT_COMPLETE_TYPE&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a017cf293f011a2315f3df2aebce86880"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a017cf293f011a2315f3df2aebce86880">reentrant_put_transaction</a> (<a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; OTHERTYPE &gt; &amp;&amp;i_source) noexcept</td></tr>
<tr class="separator:a017cf293f011a2315f3df2aebce86880"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fa93d5f3452eb0137787ffdeff47b8"><td class="memTemplParams" colspan="2">template&lt;typename OTHERTYPE , typename  = typename std::enable_if&lt;                std::is_same&lt;OTHERTYPE, ELEMENT_COMPLETE_TYPE&gt;::value ||                std::is_void&lt;ELEMENT_COMPLETE_TYPE&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a79fa93d5f3452eb0137787ffdeff47b8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a79fa93d5f3452eb0137787ffdeff47b8">operator=</a> (<a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; OTHERTYPE &gt; &amp;&amp;i_source) noexcept</td></tr>
<tr class="separator:a79fa93d5f3452eb0137787ffdeff47b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93e713eaa81209fc1fc9e18e66abfee3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a93e713eaa81209fc1fc9e18e66abfee3">raw_allocate</a> (size_t i_size, size_t i_alignment)</td></tr>
<tr class="separator:a93e713eaa81209fc1fc9e18e66abfee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92543eae2db7254d51084afd1e7deb05"><td class="memTemplParams" colspan="2">template&lt;typename INPUT_ITERATOR &gt; </td></tr>
<tr class="memitem:a92543eae2db7254d51084afd1e7deb05"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits&lt; INPUT_ITERATOR &gt;::value_type *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a92543eae2db7254d51084afd1e7deb05">raw_allocate_copy</a> (INPUT_ITERATOR i_begin, INPUT_ITERATOR i_end)</td></tr>
<tr class="separator:a92543eae2db7254d51084afd1e7deb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad9d43e253f70feef0a0b79cabf231f0"><td class="memTemplParams" colspan="2">template&lt;typename INPUT_RANGE &gt; </td></tr>
<tr class="memitem:aad9d43e253f70feef0a0b79cabf231f0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#aad9d43e253f70feef0a0b79cabf231f0">raw_allocate_copy</a> (const INPUT_RANGE &amp;i_source_range) -&gt; decltype(std::declval&lt; <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> &gt;().raw_allocate_copy(                                                           std::begin(i_source_range), std::end(i_source_range)))                                        </td></tr>
<tr class="separator:aad9d43e253f70feef0a0b79cabf231f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96491d550e91a5918050bfdafe43a72c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a96491d550e91a5918050bfdafe43a72c">commit</a> () noexcept</td></tr>
<tr class="separator:a96491d550e91a5918050bfdafe43a72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a209a4e37e25451c144910d6f6aa4911e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a209a4e37e25451c144910d6f6aa4911e">cancel</a> () noexcept</td></tr>
<tr class="separator:a209a4e37e25451c144910d6f6aa4911e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab863df8ed6316860117a6bf26e131bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#ab863df8ed6316860117a6bf26e131bbd">empty</a> () const  noexcept</td></tr>
<tr class="separator:ab863df8ed6316860117a6bf26e131bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2b1a2d00e00f238645907a7a6a54022"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#ae2b1a2d00e00f238645907a7a6a54022">operator bool</a> () const  noexcept</td></tr>
<tr class="separator:ae2b1a2d00e00f238645907a7a6a54022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd39d8c67577e93e940ef77c50562fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a> () const  noexcept</td></tr>
<tr class="separator:abfd39d8c67577e93e940ef77c50562fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61588a937bd494d75975c81f9943c785"><td class="memItemLeft" align="right" valign="top">common_type *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a61588a937bd494d75975c81f9943c785">element_ptr</a> () const  noexcept</td></tr>
<tr class="separator:a61588a937bd494d75975c81f9943c785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b14808ff215d94d093050b9146cf70d"><td class="memItemLeft" align="right" valign="top">ELEMENT_COMPLETE_TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a5b14808ff215d94d093050b9146cf70d">element</a> () const  noexcept</td></tr>
<tr class="separator:a5b14808ff215d94d093050b9146cf70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97f6c2bf3438af74d84b52ded51b122f"><td class="memItemLeft" align="right" valign="top">const RUNTIME_TYPE &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a97f6c2bf3438af74d84b52ded51b122f">complete_type</a> () const  noexcept</td></tr>
<tr class="separator:a97f6c2bf3438af74d84b52ded51b122f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7ca7b8c66ea3888e8f8b1b2fd1f59dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#aa7ca7b8c66ea3888e8f8b1b2fd1f59dc">~reentrant_put_transaction</a> ()</td></tr>
<tr class="separator:aa7ca7b8c66ea3888e8f8b1b2fd1f59dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af761cdfa5723cb3ee9b055d9c4928044"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af761cdfa5723cb3ee9b055d9c4928044"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>reentrant_put_transaction</b> (PrivateType, <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> *i_queue, Allocation i_push_data, std::true_type, void *) noexcept</td></tr>
<tr class="separator:af761cdfa5723cb3ee9b055d9c4928044"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6a1284693e97eb021d78c8bfda3e78"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acd6a1284693e97eb021d78c8bfda3e78"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>reentrant_put_transaction</b> (PrivateType, <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> *i_queue, Allocation i_push_data, std::false_type, COMMON_TYPE *i_element) noexcept</td></tr>
<tr class="separator:acd6a1284693e97eb021d78c8bfda3e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a662575161711d9067632309b25607714"><td class="memTemplParams" colspan="2"><a class="anchor" id="a662575161711d9067632309b25607714"></a>
template&lt;typename OTHERTYPE &gt; </td></tr>
<tr class="memitem:a662575161711d9067632309b25607714"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reentrant_put_transaction</b></td></tr>
<tr class="separator:a662575161711d9067632309b25607714"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be788c3e31ab4d0085b6b6ae5e18451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a7be788c3e31ab4d0085b6b6ae5e18451">swap</a> (<a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> &amp;i_first, <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> &amp;i_second) noexcept</td></tr>
<tr class="separator:a7be788c3e31ab4d0085b6b6ae5e18451"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename COMMON_TYPE = void, typename RUNTIME_TYPE = runtime_type&lt;COMMON_TYPE&gt;, typename ALLOCATOR_TYPE = default_allocator&gt;<br />
template&lt;typename ELEMENT_COMPLETE_TYPE = void&gt;<br />
class density::heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt;::reentrant_put_transaction&lt; ELEMENT_COMPLETE_TYPE &gt;</h3>

<p>Move-only class template that can be bound to a reentrant put transaction, otherwise it's empty.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ELEMENT_COMPLETE_TYPE</td><td>Complete type of elements that can be handled by a transaction, or void. ELEMENT_COMPLETE_TYPE must decay to itself (it can't be cv-qualified).</td></tr>
  </table>
  </dd>
</dl>
<p>Reentrant transactional put functions on <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> return a non-empty <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> that can be used to allocate raw memory in the queue, inspect or alter the element while it is still not observable in the queue, and commit or cancel the push.</p>
<p>A <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> is empty when:</p><ul>
<li>it is default constructed</li>
<li>it is used as source for a move construction or move assignment</li>
<li>after a cancel or a commit</li>
</ul>
<p>Calling <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a93e713eaa81209fc1fc9e18e66abfee3">raw_allocate</a>, <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a92543eae2db7254d51084afd1e7deb05">raw_allocate_copy</a>, <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a96491d550e91a5918050bfdafe43a72c">commit</a>, <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a209a4e37e25451c144910d6f6aa4911e">cancel</a>, <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a61588a937bd494d75975c81f9943c785">element_ptr</a>, <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a5b14808ff215d94d093050b9146cf70d">element</a> or <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a97f6c2bf3438af74d84b52ded51b122f">complete_type</a> on an empty <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> triggers undefined behavior.</p>
<p>A void <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> can be move constructed/assigned from any <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>. A typed <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> can be move constructed/assigned only from a <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> with the same ELEMENT_COMPLETE_TYPE. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="aade140513e6d5591cc641434959da925"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs an empty put transaction </p>

</div>
</div>
<a class="anchor" id="ad64aa5379a0a3b847080856ed5045fb2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; ELEMENT_COMPLETE_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy construction is not allowed.</p>
<div class="fragment"><div class="line">            static_assert(</div><div class="line">              !std::is_copy_constructible&lt;heter_queue&lt;&gt;::reentrant_put_transaction&lt;&gt;&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">            static_assert(</div><div class="line">              !std::is_copy_constructible&lt;heter_queue&lt;int&gt;::reentrant_put_transaction&lt;&gt;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a017cf293f011a2315f3df2aebce86880"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; OTHERTYPE &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructs a <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>, transferring the state from the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move from. It becomes empty after the call.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">            heter_queue&lt;&gt; <a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>;</div><div class="line">            <span class="keyword">auto</span>          transaction1 = queue.<a class="code" href="classdensity_1_1heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a>(1);</div><div class="line"></div><div class="line">            <span class="comment">// move from transaction1 to transaction2</span></div><div class="line">            <span class="keyword">auto</span> transaction2(std::move(transaction1));</div><div class="line">            assert(transaction1.empty());</div><div class="line">            assert(transaction2.element() == 1);</div><div class="line"></div><div class="line">            <span class="comment">// commit transaction2</span></div><div class="line">            transaction2.commit();</div><div class="line">            assert(transaction2.empty());</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line">            <span class="comment">// reentrant_put_transaction&lt;void&gt; can be move constructed from any reentrant_put_transaction&lt;T&gt;</span></div><div class="line">            static_assert(</div><div class="line">              std::is_constructible&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;void&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;void&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">            static_assert(</div><div class="line">              std::is_constructible&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;void&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">            <span class="comment">// reentrant_put_transaction&lt;T&gt; can be move constructed only from reentrant_put_transaction&lt;T&gt;</span></div><div class="line">            static_assert(</div><div class="line">              !std::is_constructible&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;void&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">            static_assert(</div><div class="line">              !std::is_constructible&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;float&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">            static_assert(</div><div class="line">              std::is_constructible&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa7ca7b8c66ea3888e8f8b1b2fd1f59dc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If this transaction is empty the destructor has no side effects. Otherwise it cancels it.</p>
<div class="fragment"><div class="line">            queue.start_reentrant_push(</div><div class="line">              42); <span class="comment">/* this transaction is destroyed without being committed,</span></div><div class="line"><span class="comment">                            so it gets canceled automatically. */</span></div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a25890d943db83f10acbbac0b2fc3a0ca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; ELEMENT_COMPLETE_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment is not allowed.</p>
<div class="fragment"><div class="line">            static_assert(</div><div class="line">              !std::is_copy_assignable&lt;heter_queue&lt;&gt;::reentrant_put_transaction&lt;&gt;&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">            static_assert(</div><div class="line">              !std::is_copy_assignable&lt;heter_queue&lt;int&gt;::reentrant_put_transaction&lt;&gt;&gt;::value, <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a79fa93d5f3452eb0137787ffdeff47b8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; OTHERTYPE &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assigns a <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>, transferring the state from the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move from. It becomes empty after the call.</td></tr>
  </table>
  </dd>
</dl>
<div class="fragment"><div class="line">            heter_queue&lt;&gt; <a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>;</div><div class="line">            <span class="keyword">auto</span>          transaction1 = queue.<a class="code" href="classdensity_1_1heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a>(1);</div><div class="line"></div><div class="line">            heter_queue&lt;&gt;::reentrant_put_transaction&lt;&gt; transaction2;</div><div class="line">            transaction2 = queue.start_reentrant_push(1);</div><div class="line">            transaction2 = std::move(transaction1);</div><div class="line">            assert(transaction1.empty());</div><div class="line">            transaction2.commit();</div><div class="line">            assert(transaction2.empty());</div></div><!-- fragment --><div class="fragment"><div class="line">            <span class="comment">// reentrant_put_transaction&lt;void&gt; can be move assigned from any reentrant_put_transaction&lt;T&gt;</span></div><div class="line">            static_assert(</div><div class="line">              std::is_assignable&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;void&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;void&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">            static_assert(</div><div class="line">              std::is_assignable&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;void&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div><div class="line"></div><div class="line">            <span class="comment">// reentrant_put_transaction&lt;T&gt; can be move assigned only from reentrant_put_transaction&lt;T&gt;</span></div><div class="line">            static_assert(</div><div class="line">              !std::is_assignable&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;void&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">            static_assert(</div><div class="line">              !std::is_assignable&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;float&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div><div class="line">            static_assert(</div><div class="line">              std::is_assignable&lt;</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt;,</div><div class="line">                heter_queue&lt;&gt;::reentrant_put_transaction&lt;int&gt; &amp;&amp;&gt;::value,</div><div class="line">              <span class="stringliteral">&quot;&quot;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a93e713eaa81209fc1fc9e18e66abfee3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* raw_allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a memory block associated to the element being added in the queue. The block may be allocated contiguously with the elements in the memory pages. If the block does not fit in one page, the block is allocated using non-paged memory services of the allocator.</p>
<p><br />
 The block doesn't need to be deallocated, and is guaranteed to be valid until the associated element is destroyed. The initial content of the block is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size in bytes of the block to allocate. </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment of the block to allocate. It must be a non-zero power of 2, and less than or equal to i_size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>this transaction is empty</li>
<li>the alignment is not valid</li>
<li>the size is not a multiple of the alignment</li>
</ul>
</dd></dl>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<div class="fragment"><div class="line">            heter_queue&lt;&gt; <a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>;</div><div class="line">            <span class="keyword">struct </span>Msg</div><div class="line">            {</div><div class="line">                std::chrono::high_resolution_clock::time_point m_time =</div><div class="line">                  std::chrono::high_resolution_clock::now();</div><div class="line">                <span class="keywordtype">size_t</span> m_len  = 0;</div><div class="line">                <span class="keywordtype">void</span> * m_data = <span class="keyword">nullptr</span>;</div><div class="line">            };</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> post_message = [&amp;<a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>](<span class="keyword">const</span> <span class="keywordtype">void</span> * i_data, <span class="keywordtype">size_t</span> i_len) {</div><div class="line">                <span class="keyword">auto</span> transaction             = queue.start_reentrant_emplace&lt;Msg&gt;();</div><div class="line">                transaction.element().m_len  = i_len;</div><div class="line">                transaction.element().m_data = transaction.raw_allocate(i_len, 1);</div><div class="line">                memcpy(transaction.element().m_data, i_data, i_len);</div><div class="line"></div><div class="line">                assert(</div><div class="line">                  !transaction</div><div class="line">                     .<a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#ab863df8ed6316860117a6bf26e131bbd">empty</a>()); <span class="comment">// a put transaction is not empty if it&#39;s bound to an element being put</span></div><div class="line">                transaction.commit();</div><div class="line">                assert(transaction.empty()); <span class="comment">// the commit makes the transaction empty</span></div><div class="line">            };</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> <span class="keyword">const</span> start_time = std::chrono::high_resolution_clock::now();</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> consume_all_msgs = [&amp;<a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>, &amp;start_time] {</div><div class="line">                <span class="keywordflow">while</span> (<span class="keyword">auto</span> consume = queue.try_start_reentrant_consume())</div><div class="line">                {</div><div class="line">                    <span class="keyword">auto</span> <span class="keyword">const</span> checksum =</div><div class="line">                      compute_checksum(consume.element&lt;Msg&gt;().m_data, consume.element&lt;Msg&gt;().m_len);</div><div class="line">                    std::cout &lt;&lt; <span class="stringliteral">&quot;Message with checksum &quot;</span> &lt;&lt; checksum &lt;&lt; <span class="stringliteral">&quot; at &quot;</span>;</div><div class="line">                    std::cout &lt;&lt; (consume.element&lt;Msg&gt;().m_time - start_time).count() &lt;&lt; std::endl;</div><div class="line">                    consume.commit();</div><div class="line">                }</div><div class="line">            };</div><div class="line"></div><div class="line">            <span class="keywordtype">int</span> msg_1 = 42, msg_2 = 567;</div><div class="line">            post_message(&amp;msg_1, <span class="keyword">sizeof</span>(msg_1));</div><div class="line">            post_message(&amp;msg_2, <span class="keyword">sizeof</span>(msg_2));</div><div class="line"></div><div class="line">            consume_all_msgs();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a92543eae2db7254d51084afd1e7deb05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;INPUT_ITERATOR&gt;::value_type* raw_allocate_copy </td>
          <td>(</td>
          <td class="paramtype">INPUT_ITERATOR&#160;</td>
          <td class="paramname"><em>i_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INPUT_ITERATOR&#160;</td>
          <td class="paramname"><em>i_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a memory block associated to the element being added in the queue, and copies the content from a range of iterators. The block may be allocated contiguously with the elements in the memory pages. If the block does not fit in one page, the block is allocated using non-paged memory services of the allocator.</p>
<p><br />
 The block doesn't need to be deallocated, and is guaranteed to be valid until the associated element is destroyed. The initial content of the block is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_begin</td><td>first element to be copied </td></tr>
    <tr><td class="paramname">i_end</td><td>first element not to be copied</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>INPUT_ITERATOR must meet the requirements of <a href="http://en.cppreference.com/w/cpp/concept/InputIterator">InputIterator</a></li>
<li>the value type must be trivially destructible</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>this transaction is empty</li>
<li>i_end is not reachable from i_begin</li>
</ul>
</dd></dl>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects)</p>
<div class="fragment"><div class="line">            <span class="keyword">struct </span>Msg</div><div class="line">            {</div><div class="line">                <span class="keywordtype">size_t</span> m_len   = 0;</div><div class="line">                <span class="keywordtype">char</span> * m_chars = <span class="keyword">nullptr</span>;</div><div class="line">            };</div><div class="line">            <span class="keyword">auto</span> post_message = [&amp;<a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>](<span class="keyword">const</span> <span class="keywordtype">char</span> * i_data, <span class="keywordtype">size_t</span> i_len) {</div><div class="line">                <span class="keyword">auto</span> transaction            = queue.start_reentrant_emplace&lt;Msg&gt;();</div><div class="line">                transaction.element().m_len = i_len;</div><div class="line">                transaction.element().m_chars =</div><div class="line">                  transaction.raw_allocate_copy(i_data, i_data + i_len);</div><div class="line">                memcpy(transaction.element().m_chars, i_data, i_len);</div><div class="line">                transaction.commit();</div><div class="line">            };</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aad9d43e253f70feef0a0b79cabf231f0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto raw_allocate_copy </td>
          <td>(</td>
          <td class="paramtype">const INPUT_RANGE &amp;&#160;</td>
          <td class="paramname"><em>i_source_range</em></td><td>)</td>
          <td> -&gt; decltype(std::declval&lt;<a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&gt;().raw_allocate_copy(
                std::begin(i_source_range), std::end(i_source_range)))
            </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a memory block associated to the element being added in the queue, and copies the content from a range. The block may be allocated contiguously with the elements in the memory pages. If the block does not fit in one page, the block is allocated using non-paged memory services of the allocator.</p>
<p><br />
 The block doesn't need to be deallocated, and is guaranteed to be valid until the associated element is destroyed. The initial content of the block is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source_range</td><td>to be copied</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The iterators of the range must meet the requirements of <a href="http://en.cppreference.com/w/cpp/concept/InputIterator">InputIterator</a></li>
<li>the value type must be trivially destructible</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>this transaction is empty</li>
</ul>
</dd></dl>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<div class="fragment"><div class="line">            <span class="keyword">struct </span>Msg</div><div class="line">            {</div><div class="line">                <span class="keywordtype">char</span> * m_chars = <span class="keyword">nullptr</span>;</div><div class="line">            };</div><div class="line">            <span class="keyword">auto</span> post_message = [&amp;<a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>](<span class="keyword">const</span> std::string &amp; i_string) {</div><div class="line">                <span class="keyword">auto</span> transaction              = queue.start_reentrant_emplace&lt;Msg&gt;();</div><div class="line">                transaction.element().m_chars = transaction.raw_allocate_copy(i_string);</div><div class="line">                transaction.commit();</div><div class="line">            };</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a96491d550e91a5918050bfdafe43a72c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void commit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Makes the effects of the transaction observable. This object becomes empty.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>this transaction is empty</li>
</ul>
</dd></dl>
<p><b>Complexity</b>: Constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: Nothing. </p>

</div>
</div>
<a class="anchor" id="a209a4e37e25451c144910d6f6aa4911e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void cancel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Cancel the transaction. This object becomes empty.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>this transaction is empty</li>
</ul>
</dd></dl>
<p><b>Complexity</b>: Constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: Nothing.</p>
<div class="fragment"><div class="line">            heter_queue&lt;&gt; <a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>;</div><div class="line"></div><div class="line">            <span class="comment">// start and cancel a put</span></div><div class="line">            assert(queue.empty());</div><div class="line">            <span class="keyword">auto</span> put = queue.<a class="code" href="classdensity_1_1heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a>(42);</div><div class="line">            <span class="comment">/* assert(queue.empty()); &lt;- this assert would trigger an undefined behavior, because it would access</span></div><div class="line"><span class="comment">        the queue during a non-reentrant put transaction. */</span></div><div class="line">            assert(!put.empty());</div><div class="line">            put.cancel();</div><div class="line">            assert(queue.empty() &amp;&amp; put.empty());</div><div class="line"></div><div class="line">            <span class="comment">// start and commit a put</span></div><div class="line">            put = queue.start_reentrant_push(42);</div><div class="line">            put.commit();</div><div class="line">            assert(std::distance(queue.cbegin(), queue.cend()) == 1);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab863df8ed6316860117a6bf26e131bbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true whether this object does not hold the state of a transaction.</p>
<div class="fragment"><div class="line">            heter_queue&lt;&gt;::reentrant_put_transaction&lt;&gt; transaction;</div><div class="line">            assert(transaction.empty());</div><div class="line"></div><div class="line">            transaction = queue.start_reentrant_push(1);</div><div class="line">            assert(!transaction.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae2b1a2d00e00f238645907a7a6a54022"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">operator bool </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true whether this object is bound to a transaction. Same to !consume_operation::empty.</p>
<div class="fragment"><div class="line">            heter_queue&lt;&gt;::reentrant_put_transaction&lt;&gt; transaction;</div><div class="line">            assert(!transaction);</div><div class="line"></div><div class="line">            transaction = queue.start_reentrant_push(1);</div><div class="line">            assert(transaction);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abfd39d8c67577e93e940ef77c50562fd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>* queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the target queue if a transaction is bound, otherwise returns nullptr</p>
<div class="fragment"><div class="line">            heter_queue&lt;&gt;::reentrant_put_transaction&lt;&gt; transaction;</div><div class="line">            assert(transaction.queue() == <span class="keyword">nullptr</span>);</div><div class="line"></div><div class="line">            transaction = queue.start_reentrant_push(1);</div><div class="line">            assert(transaction.queue() == &amp;<a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#abfd39d8c67577e93e940ef77c50562fd">queue</a>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a61588a937bd494d75975c81f9943c785"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">common_type* element_ptr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a pointer to the object being added. <br />
 <em>Notes</em>:</p><ul>
<li>The object is constructed when the transaction is started, so this function always returns a pointer to a valid object.</li>
<li>This function returns a pointer to the common_type subobject of the element. Non-dynamic transactional put function (start_push, start_emplace, start_reentrant_push, start_reentrant_emplace) return a typed_put_transaction or a <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>, that provide the function <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a5b14808ff215d94d093050b9146cf70d">element()</a>, which is a better alternative to this function</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>this transaction is empty</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">            <span class="keywordtype">int</span>  value = 42;</div><div class="line">            <span class="keyword">auto</span> put =</div><div class="line">              queue.start_reentrant_dyn_push_copy(<a class="code" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type&lt;&gt;::make</a>&lt;decltype(value)&gt;(), &amp;value);</div><div class="line">            assert(*static_cast&lt;int *&gt;(put.element_ptr()) == 42);</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Putting an &quot;</span> &lt;&lt; put.complete_type().type_info().name() &lt;&lt; <span class="stringliteral">&quot;...&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div><div class="line"></div></div><!-- fragment --> <div class="fragment"><div class="line">            <span class="keyword">auto</span> put_1 = queue.start_reentrant_push(1);</div><div class="line">            assert(*static_cast&lt;int *&gt;(put_1.element_ptr()) == 1); <span class="comment">// this is fine</span></div><div class="line">            assert(put_1.element() == 1);                          <span class="comment">// this is better</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5b14808ff215d94d093050b9146cf70d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ELEMENT_COMPLETE_TYPE&amp; element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the element being added. This function can be used to modify the element before calling the commit. <br />
 <em>Note</em>: An element is observable in the queue only after commit has been called on the <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>. The element is constructed at the begin of the transaction, so the returned object is always valid.</p>
<p><br />
 <b>Requires</b>:</p><ul>
<li>ELEMENT_COMPLETE_TYPE must not be void</li>
</ul>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if:<ul>
<li>this transaction is empty</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line"></div><div class="line">            <span class="keywordtype">int</span>  value = 42;</div><div class="line">            <span class="keyword">auto</span> untyped_put =</div><div class="line">              queue.start_reentrant_dyn_push_copy(<a class="code" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type&lt;&gt;::make</a>&lt;decltype(value)&gt;(), &amp;value);</div><div class="line"></div><div class="line">            <span class="keyword">auto</span> typed_put = queue.start_reentrant_push(42.);</div><div class="line"></div><div class="line">            <span class="comment">/* typed_put = std::move(untyped_put); &lt;- this would not compile: can&#39;t assign an untyped</span></div><div class="line"><span class="comment">        transaction to a typed transaction */</span></div><div class="line"></div><div class="line">            assert(typed_put.element() == 42.);</div><div class="line"></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a97f6c2bf3438af74d84b52ded51b122f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const RUNTIME_TYPE&amp; complete_type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the type of the object being added.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>this transaction is empty</li>
</ul>
</dd></dl>
<div class="fragment"><div class="line">            <span class="keywordtype">int</span>  value = 42;</div><div class="line">            <span class="keyword">auto</span> put =</div><div class="line">              queue.start_reentrant_dyn_push_copy(<a class="code" href="classdensity_1_1runtime__type.html#ab886d51d6e9787a4a9eee9455e024e01">runtime_type&lt;&gt;::make</a>&lt;decltype(value)&gt;(), &amp;value);</div><div class="line">            assert(put.complete_type().is&lt;<span class="keywordtype">int</span>&gt;());</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;Putting an &quot;</span> &lt;&lt; put.complete_type().type_info().name() &lt;&lt; <span class="stringliteral">&quot;...&quot;</span></div><div class="line">                      &lt;&lt; std::endl;</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a7be788c3e31ab4d0085b6b6ae5e18451"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; ELEMENT_COMPLETE_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; ELEMENT_COMPLETE_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps two instances of <a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>.</p>
<div class="fragment"></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/density/density/<a class="el" href="heter__queue_8h_source.html">heter_queue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
