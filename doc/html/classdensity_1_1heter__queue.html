<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>density: heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">density
   </div>
   <div id="projectbrief">C++11 library for paged memory management, function queues, heterogeneous queues and lifo memory management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedensity.html">density</a></li><li class="navelem"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdensity_1_1heter__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="heter__queue_8h_source.html">heter_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa751aeee567f3a896028bc26f5737372"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa751aeee567f3a896028bc26f5737372"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>common_type</b> = COMMON_TYPE</td></tr>
<tr class="separator:aa751aeee567f3a896028bc26f5737372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b50f4f25fd3da4205169b7280303e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad98b50f4f25fd3da4205169b7280303e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>runtime_type</b> = RUNTIME_TYPE</td></tr>
<tr class="separator:ad98b50f4f25fd3da4205169b7280303e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9253fca0e3b116143a118d211fb39002"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9253fca0e3b116143a118d211fb39002"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = std::pair&lt; const runtime_type &amp;, common_type *const  &gt;</td></tr>
<tr class="separator:a9253fca0e3b116143a118d211fb39002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bafeb4e974cce856d533d2bb3de432"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8bafeb4e974cce856d533d2bb3de432"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>allocator_type</b> = ALLOCATOR_TYPE</td></tr>
<tr class="separator:ad8bafeb4e974cce856d533d2bb3de432"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc03915d7633dfe3c2b7a160f410549"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6fc03915d7633dfe3c2b7a160f410549"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b> = value_type *</td></tr>
<tr class="separator:a6fc03915d7633dfe3c2b7a160f410549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce9d8c8e35f6c6ffb564c2e733ea05e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ce9d8c8e35f6c6ffb564c2e733ea05e"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b> = const value_type *</td></tr>
<tr class="separator:a1ce9d8c8e35f6c6ffb564c2e733ea05e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad22bd40cacb993e9bf49cf10e7ef245a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad22bd40cacb993e9bf49cf10e7ef245a"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b> = value_type</td></tr>
<tr class="separator:ad22bd40cacb993e9bf49cf10e7ef245a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1137da269e66589b98fce3416d40502"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab1137da269e66589b98fce3416d40502"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b> = const value_type &amp;</td></tr>
<tr class="separator:ab1137da269e66589b98fce3416d40502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38ce1af42d538f410180c265518d4f0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af38ce1af42d538f410180c265518d4f0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = std::size_t</td></tr>
<tr class="separator:af38ce1af42d538f410180c265518d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace405568d0b2f3fad4990044252c7732"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ace405568d0b2f3fad4990044252c7732"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b> = std::ptrdiff_t</td></tr>
<tr class="separator:ace405568d0b2f3fad4990044252c7732"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9c23132776e1a22b999040f3566bb678"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a9c23132776e1a22b999040f3566bb678">heter_queue</a> () noexcept</td></tr>
<tr class="separator:a9c23132776e1a22b999040f3566bb678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af29d98e4a12f62328d46386aa469d504"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#af29d98e4a12f62328d46386aa469d504">heter_queue</a> (const ALLOCATOR_TYPE &amp;i_source_allocator) noexcept(std::is_nothrow_copy_constructible&lt; ALLOCATOR_TYPE &gt;::value)</td></tr>
<tr class="separator:af29d98e4a12f62328d46386aa469d504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a400becac15c51a0aa865c34162c48eb7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a400becac15c51a0aa865c34162c48eb7">heter_queue</a> (ALLOCATOR_TYPE &amp;&amp;i_source_allocator) noexcept</td></tr>
<tr class="separator:a400becac15c51a0aa865c34162c48eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b1139d294569f6ffe93170c316be9ab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a1b1139d294569f6ffe93170c316be9ab">heter_queue</a> (<a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> &amp;&amp;i_source) noexcept</td></tr>
<tr class="separator:a1b1139d294569f6ffe93170c316be9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbcb0b90dd090a2b5850fd799e33b549"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#abbcb0b90dd090a2b5850fd799e33b549">heter_queue</a> (const <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> &amp;i_source)</td></tr>
<tr class="separator:abbcb0b90dd090a2b5850fd799e33b549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61545ab5341627323a3d71121930b7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#ab61545ab5341627323a3d71121930b7a">operator=</a> (<a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> &amp;&amp;i_source) noexcept</td></tr>
<tr class="separator:ab61545ab5341627323a3d71121930b7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c36a623ab4dad8d3c9e36b48feb3463"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a3c36a623ab4dad8d3c9e36b48feb3463">operator=</a> (const <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> &amp;i_source)</td></tr>
<tr class="separator:a3c36a623ab4dad8d3c9e36b48feb3463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac29f19b7f4021ce4a40e84ab895ab453"><td class="memItemLeft" align="right" valign="top">allocator_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#ac29f19b7f4021ce4a40e84ab895ab453">get_allocator</a> () noexcept(std::is_nothrow_copy_constructible&lt; allocator_type &gt;::value)</td></tr>
<tr class="separator:ac29f19b7f4021ce4a40e84ab895ab453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6418bf0426ef570443a93d4456fa523"><td class="memItemLeft" align="right" valign="top">allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#ab6418bf0426ef570443a93d4456fa523">get_allocator_ref</a> () noexcept</td></tr>
<tr class="separator:ab6418bf0426ef570443a93d4456fa523"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15eaf0df4f1d8976f3e799f796dc6f7c"><td class="memItemLeft" align="right" valign="top">const allocator_type &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a15eaf0df4f1d8976f3e799f796dc6f7c">get_allocator_ref</a> () const  noexcept</td></tr>
<tr class="separator:a15eaf0df4f1d8976f3e799f796dc6f7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fbfbfd87e69190da4a54f952f9ea20f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a4fbfbfd87e69190da4a54f952f9ea20f">~heter_queue</a> ()</td></tr>
<tr class="separator:a4fbfbfd87e69190da4a54f952f9ea20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab863df8ed6316860117a6bf26e131bbd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#ab863df8ed6316860117a6bf26e131bbd">empty</a> () const  noexcept</td></tr>
<tr class="separator:ab863df8ed6316860117a6bf26e131bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03bfacfaaba9195e4498375659f43531"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a03bfacfaaba9195e4498375659f43531">clear</a> () noexcept</td></tr>
<tr class="separator:a03bfacfaaba9195e4498375659f43531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:ae79645ce0f8c0616bbfda669fa6fbadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94888fab06d0078cd93ac1562fcce9bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a94888fab06d0078cd93ac1562fcce9bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52867536308877c33bfb29f5ca8c9ebc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a52867536308877c33bfb29f5ca8c9ebc">dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a52867536308877c33bfb29f5ca8c9ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da90ba09177e403d9bd6f466d332eca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a8da90ba09177e403d9bd6f466d332eca">dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a8da90ba09177e403d9bd6f466d332eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857a56adb973d294e1cf85acca8efbad"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a857a56adb973d294e1cf85acca8efbad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a857a56adb973d294e1cf85acca8efbad">start_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:a857a56adb973d294e1cf85acca8efbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722ecea4d64dc7853d3825f24f316b47"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a722ecea4d64dc7853d3825f24f316b47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">start_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a722ecea4d64dc7853d3825f24f316b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65085a9e9c299f23ad95b297752d3775"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a65085a9e9c299f23ad95b297752d3775">start_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a65085a9e9c299f23ad95b297752d3775"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2746c80dae973ad196b7f12c1bbcc8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#aac2746c80dae973ad196b7f12c1bbcc8">start_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:aac2746c80dae973ad196b7f12c1bbcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194977988482bd3bcfeb92c14ccef60a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a194977988482bd3bcfeb92c14ccef60a">start_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a194977988482bd3bcfeb92c14ccef60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274dca2a1d2c68ff3249f37b3ae410d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a274dca2a1d2c68ff3249f37b3ae410d5">pop</a> () noexcept</td></tr>
<tr class="separator:a274dca2a1d2c68ff3249f37b3ae410d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b9c85fad7f5d27b7555c29b2e4e3fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a35b9c85fad7f5d27b7555c29b2e4e3fe">try_pop</a> () noexcept</td></tr>
<tr class="separator:a35b9c85fad7f5d27b7555c29b2e4e3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6f1ab782b6edf567268eee5613c82d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#ac6f1ab782b6edf567268eee5613c82d1">try_start_consume</a> () noexcept</td></tr>
<tr class="separator:ac6f1ab782b6edf567268eee5613c82d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a616b75e28b72dcb69afe98280ad561e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a616b75e28b72dcb69afe98280ad561e0">try_start_consume</a> (<a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> &amp;i_consume) noexcept</td></tr>
<tr class="separator:a616b75e28b72dcb69afe98280ad561e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4493f55adeab87efb382c118066a2e"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:abd4493f55adeab87efb382c118066a2e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#abd4493f55adeab87efb382c118066a2e">reentrant_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:abd4493f55adeab87efb382c118066a2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a99a0cef94c1cde53cf68ce8c11bbc74f">reentrant_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22a0faba214d7f09f7af2d8ee795490d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a22a0faba214d7f09f7af2d8ee795490d">reentrant_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a22a0faba214d7f09f7af2d8ee795490d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fc9a353af5e0de17d9cd2c74876c3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a09fc9a353af5e0de17d9cd2c74876c3f">reentrant_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a09fc9a353af5e0de17d9cd2c74876c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711a4f42d9c13317c6a1412686c42609"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a711a4f42d9c13317c6a1412686c42609">reentrant_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a711a4f42d9c13317c6a1412686c42609"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3c73b2740ce46477422fb90d18208"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a43e3c73b2740ce46477422fb90d18208"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:a43e3c73b2740ce46477422fb90d18208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa035e6311be7c63c72334427572193"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a6aa035e6311be7c63c72334427572193"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a6aa035e6311be7c63c72334427572193">start_reentrant_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a6aa035e6311be7c63c72334427572193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298d63c59edac31a0d50efc67bdd9381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a298d63c59edac31a0d50efc67bdd9381">start_reentrant_dyn_push</a> (const runtime_type &amp;i_type)</td></tr>
<tr class="separator:a298d63c59edac31a0d50efc67bdd9381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55249c74018c4dad488fb1eebec8bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a55249c74018c4dad488fb1eebec8bde3">start_reentrant_dyn_push_copy</a> (const runtime_type &amp;i_type, const COMMON_TYPE *i_source)</td></tr>
<tr class="separator:a55249c74018c4dad488fb1eebec8bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6abd47f0a85b6d2f90de584c05270c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#af6abd47f0a85b6d2f90de584c05270c0">start_reentrant_dyn_push_move</a> (const runtime_type &amp;i_type, COMMON_TYPE *i_source)</td></tr>
<tr class="separator:af6abd47f0a85b6d2f90de584c05270c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa83c43fd2aca56043d4209f67dd579a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#aa83c43fd2aca56043d4209f67dd579a1">reentrant_pop</a> () noexcept</td></tr>
<tr class="separator:aa83c43fd2aca56043d4209f67dd579a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83d6e59ab5dec61205db0cea6e6cf5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#ac83d6e59ab5dec61205db0cea6e6cf5b">try_reentrant_pop</a> () noexcept</td></tr>
<tr class="separator:ac83d6e59ab5dec61205db0cea6e6cf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af139b5f22f2d241df4e26e8da9d95f4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#af139b5f22f2d241df4e26e8da9d95f4d">try_start_reentrant_consume</a> () noexcept</td></tr>
<tr class="separator:af139b5f22f2d241df4e26e8da9d95f4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0a2b3d02d22ceb03b4bf8efdf13d47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#aab0a2b3d02d22ceb03b4bf8efdf13d47">try_start_reentrant_consume</a> (<a class="el" href="classdensity_1_1heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> &amp;i_consume) noexcept</td></tr>
<tr class="separator:aab0a2b3d02d22ceb03b4bf8efdf13d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a89d405dd251ef9da6a7da47dea2d1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae7a89d405dd251ef9da6a7da47dea2d1"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>begin</b> () const  noexcept</td></tr>
<tr class="separator:ae7a89d405dd251ef9da6a7da47dea2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e4c739cecc04d108350400afca8062"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af6e4c739cecc04d108350400afca8062"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>end</b> () const  noexcept</td></tr>
<tr class="separator:af6e4c739cecc04d108350400afca8062"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa305eb19baab273d1206a16c8e5d8fa0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa305eb19baab273d1206a16c8e5d8fa0"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cbegin</b> () const  noexcept</td></tr>
<tr class="separator:aa305eb19baab273d1206a16c8e5d8fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f5c5b7cfa929319fcea4932622c8b5a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4f5c5b7cfa929319fcea4932622c8b5a"></a>
const_iterator&#160;</td><td class="memItemRight" valign="bottom"><b>cend</b> () const  noexcept</td></tr>
<tr class="separator:a4f5c5b7cfa929319fcea4932622c8b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455b06c26dd46d98bf859b924719e657"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a455b06c26dd46d98bf859b924719e657">operator==</a> (const <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> &amp;i_source) const </td></tr>
<tr class="separator:a455b06c26dd46d98bf859b924719e657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab104611a8554c4ee98ff653b8defc6ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#ab104611a8554c4ee98ff653b8defc6ef">operator!=</a> (const <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> &amp;i_source) const </td></tr>
<tr class="separator:ab104611a8554c4ee98ff653b8defc6ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a2cdcdcfbd2342ad05b1c907bfaf76703"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a2cdcdcfbd2342ad05b1c907bfaf76703">min_alignment</a></td></tr>
<tr class="separator:a2cdcdcfbd2342ad05b1c907bfaf76703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58697d487018a8bde47d4c274c7bd76a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a58697d487018a8bde47d4c274c7bd76a">concurrent_puts</a> = false</td></tr>
<tr class="separator:a58697d487018a8bde47d4c274c7bd76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2bd4f332d922d3024a4bb65f9d17e4"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a2e2bd4f332d922d3024a4bb65f9d17e4">concurrent_consumes</a> = false</td></tr>
<tr class="separator:a2e2bd4f332d922d3024a4bb65f9d17e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30744c14b0233cd7f55466ff04151aa9"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a30744c14b0233cd7f55466ff04151aa9">concurrent_put_consumes</a> = false</td></tr>
<tr class="separator:a30744c14b0233cd7f55466ff04151aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7708a88b67261ef454d875047bcfa79d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a7708a88b67261ef454d875047bcfa79d">is_seq_cst</a> = true</td></tr>
<tr class="separator:a7708a88b67261ef454d875047bcfa79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2685ae9e207561c284a1d61e28572156"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1heter__queue.html#a2685ae9e207561c284a1d61e28572156">swap</a> (<a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;i_first, <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;i_second) noexcept</td></tr>
<tr class="separator:a2685ae9e207561c284a1d61e28572156"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename COMMON_TYPE = void, typename RUNTIME_TYPE = runtime_type&lt;COMMON_TYPE&gt;, typename ALLOCATOR_TYPE = void_allocator&gt;<br />
class density::heter_queue&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt;</h3>

<p>Class template implementing an heterogeneous FIFO pseudo-container.</p>
<p>A value of <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> is a pair of a runtime type object bound to a type E, and an object of type E (called element). <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> is an heterogeneous pseudo-container: elements in the same queue can have different types. Elements can be added only at the end (<em>put operation</em>), and can be removed only at the beginning (<em>consume operation</em>). When doing a put, the user may associate one or more <em>raw memory blocks</em> to the element. Raw blocks are deallocated automatically when the value is consumed. <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> supports iterators, but they are just <a href="http://en.cppreference.com/w/cpp/concept/InputIterator">Input Iterators</a> so <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> is not a container.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">COMMON_TYPE</td><td>Common type of all the elements. An object of type <code>E</code> can be pushed on the queue only if <code>E*</code> is implicitly convertible to <code>COMMON_TYPE*</code>. If <code>COMMON_TYPE</code> is <code>void</code> (the default), any type can be put in the queue. Otherwise it should be an user-defined-type, and only types deriving from it can be added. </td></tr>
    <tr><td class="paramname">RUNTIME_TYPE</td><td>Runtime-type object used to handle the actual complete type of each element. This type must meet the requirements of <a class="el" href="RuntimeType_concept.html">RuntimeType</a>. The default is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>. </td></tr>
    <tr><td class="paramname">ALLOCATOR_TYPE</td><td>Allocator type to be used. This type must meet the requirements of both <a class="el" href="UntypedAllocator_concept.html">UntypedAllocator</a> and <a class="el" href="PagedAllocator_concept.html">PagedAllocator</a>. The default is <a class="el" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">density::void_allocator</a>.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Thread safeness</b>: None. The user is responsible of avoiding data races. <br />
 <b>Exception safeness</b>: Any function of <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> is noexcept or provides the strong exception guarantee.</p>
<h2>Basic usage </h2>
<p>Elements can be added with <a class="el" href="classdensity_1_1heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a> or <a class="el" href="classdensity_1_1heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">emplace</a>:</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    queue.push(19); <span class="comment">// the parameter can be an l-value or an r-value</span></div><div class="line">    queue.emplace&lt;std::string&gt;(8, <span class="charliteral">&#39;*&#39;</span>); <span class="comment">// pushes &quot;********&quot;</span></div></div><!-- fragment --><p> In the above code the type of the element is fixed at compile time. In the case of emplace, it is not dependent on the type of the arguments, so it must be explicitly specified.</p>
<p>Put operations can be transactional, in which case the name of the function contains <code>start_</code>:</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    <span class="keyword">struct </span>MessageInABottle</div><div class="line">    {</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">char</span> * m_text = <span class="keyword">nullptr</span>;</div><div class="line">    };</div><div class="line">    <span class="keyword">auto</span> transaction = queue.start_emplace&lt;MessageInABottle&gt;();</div><div class="line">    transaction.element().m_text = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world!&quot;</span>);</div><div class="line">    transaction.commit();</div></div><!-- fragment --><p> Transactional puts returns an object of type <a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a> that should be used to commit or cancel the transaction. If a transaction is destroyed before being committed, it is canceled automatically. Before being committed, a transaction has no observable side effects (it does have non-observable side effects anyway, like the reservation of space in a page). The functions <a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html#a93e713eaa81209fc1fc9e18e66abfee3">raw_allocate</a> and <a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html#a92543eae2db7254d51084afd1e7deb05">raw_allocate_copy</a> allows to associate one or more raw memory blocks to the element. In this case the element should keep the pointer to the blocks (otherwise consumers are not able to access the blocks). Only transactional puts can allocate raw blocks.</p>
<p>The function <a class="el" href="classdensity_1_1heter__queue.html#ac6f1ab782b6edf567268eee5613c82d1">try_start_consume</a> can be used to consume an element. The returned object has type <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a>, which is similar to <a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a> (it can be canceled or committed), with the difference that it has observable side effects before commit or cancel is called: the element disappears from the queue when <code>try_start_consume</code> is called, and re-appears whenever cancel is called (or the <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> is destroyed without being committed).</p>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_consume();</div><div class="line">    <span class="keywordflow">if</span> (consume.complete_type().is&lt;std::string&gt;())</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; consume.element&lt;std::string&gt;() &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (consume.complete_type().is&lt;MessageInABottle&gt;())</div><div class="line">    {</div><div class="line">        std::cout &lt;&lt; consume.element&lt;MessageInABottle&gt;().m_text &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line">    consume.commit();</div></div><!-- fragment --><p> The example above searches for an exact match of the type being consumed (using <a class="el" href="classdensity_1_1runtime__type.html#a7420a5e28322c9a7a3348d35b46fbe66">runtime_type::is</a>). Anyway <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> (the default <code>RUNTIME_TYPE</code>) allows to add custom functions that can be called regardless of the type. The following example uses the built-in <a class="el" href="structdensity_1_1type__features_1_1ostream.html">type_features::ostream</a>:</p>
<div class="fragment"><div class="line">    <span class="keyword">using namespace </span><a class="code" href="namespacedensity.html">density</a>;</div><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line"></div><div class="line">    <span class="comment">/* a runtime_type is internally like a pointer to a v-table, but it can</span></div><div class="line"><span class="comment">        contain functions or data (like in the case of size and alignment). */</span></div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, ostream, istream, rtti&gt;&gt;;</div><div class="line"></div><div class="line">    <a class="code" href="classdensity_1_1heter__queue.html">heter_queue&lt;void, MyRunTimeType&gt;</a> queue;</div><div class="line">    queue.<a class="code" href="classdensity_1_1heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a>(4);</div><div class="line">    queue.<a class="code" href="classdensity_1_1heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a>(std::complex&lt;double&gt;(1., 4.));</div><div class="line">    queue.<a class="code" href="classdensity_1_1heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">emplace</a>&lt;std::string&gt;(<span class="stringliteral">&quot;Hello!!&quot;</span>);</div><div class="line">    <span class="comment">// queue.emplace&lt;std::thread&gt;(); - This would not compile because std::thread does not have a &lt;&lt; operator for streams</span></div><div class="line"></div><div class="line">    <span class="comment">// consume all the elements</span></div><div class="line">    <span class="keywordflow">while</span> (<span class="keyword">auto</span> consume = queue.<a class="code" href="classdensity_1_1heter__queue.html#ac6f1ab782b6edf567268eee5613c82d1">try_start_consume</a>())</div><div class="line">    {</div><div class="line">        <span class="comment">/* this is like: give me the function at the 6-th row in the v-table. The type ostream</span></div><div class="line"><span class="comment">            is converted to an index at compile time. */</span></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> ostream_feature = consume.complete_type().get_feature&lt;ostream&gt;();</div><div class="line"></div><div class="line">        ostream_feature(std::cout, consume.element_ptr()); <span class="comment">// this invokes the feature</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div><div class="line">        consume.commit();  <span class="comment">// don&#39;t forget the commit, otherwise the element will remain in the queue</span></div><div class="line">    }</div></div><!-- fragment --><p> An element of a type unknown at compile time may be pushed, in which case <a class="el" href="classdensity_1_1heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">dyn_push</a> can be used:</p>
<div class="fragment"><div class="line">    <span class="comment">// this local function reads from std::cin an object of a given type and puts it in the queue</span></div><div class="line">    <span class="keyword">auto</span> ask_and_put = [&amp;](<span class="keyword">const</span> MyRunTimeType &amp; i_type) {</div><div class="line"></div><div class="line">        <span class="comment">// for this we exploit the feature rtti that we have included in MyRunTimeType</span></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Enter a &quot;</span> &lt;&lt; i_type.type_info().name() &lt;&lt; std::endl;</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> <span class="keyword">const</span> istream_feature = i_type.get_feature&lt;istream&gt;();</div><div class="line"></div><div class="line">        <span class="keyword">auto</span> put = queue.<a class="code" href="classdensity_1_1heter__queue.html#a65085a9e9c299f23ad95b297752d3775">start_dyn_push</a>(i_type);</div><div class="line">        istream_feature(std::cin, put.element_ptr());</div><div class="line"></div><div class="line">        <span class="comment">/* if an exception is thrown before the commit, the put is canceled without ever</span></div><div class="line"><span class="comment">            having observable side effects. */</span></div><div class="line">        put.<a class="code" href="classdensity_1_1heter__queue_1_1put__transaction.html#a96491d550e91a5918050bfdafe43a72c">commit</a>();</div><div class="line">    };</div><div class="line"></div><div class="line">    ask_and_put(MyRunTimeType::make&lt;int&gt;());</div><div class="line">    ask_and_put(MyRunTimeType::make&lt;std::string&gt;());</div></div><!-- fragment --><p> Member functions containing <code>reentrant_</code> in their names support reentrancy: while they are in progress, other puts, consumes, iterations and any non-life-time operation are allowed, but only in the same thread (reentrancy has nothing to do with multithreading). <br />
In contrast, while a non-reentrant operation is in progress, the queue is not in a consistent state: if during a put the the operation member functions on the same queue are directly or indirectly called, the behavior is undefined. Reentrant and non-reentrant operation can be mixed, provided that the above constraint is respected.</p>
<div class="fragment"><div class="line">    <span class="comment">// start 3 reentrant put transactions</span></div><div class="line">    <span class="keyword">auto</span> put_1 = queue.<a class="code" href="classdensity_1_1heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a>(1);</div><div class="line">    <span class="keyword">auto</span> put_2 = queue.<a class="code" href="classdensity_1_1heter__queue.html#a6aa035e6311be7c63c72334427572193">start_reentrant_emplace</a>&lt;std::string&gt;(<span class="stringliteral">&quot;Hello world!&quot;</span>);</div><div class="line">    <span class="keywordtype">double</span> pi = 3.14;</div><div class="line">    <span class="keyword">auto</span> put_3 = queue.<a class="code" href="classdensity_1_1heter__queue.html#a55249c74018c4dad488fb1eebec8bde3">start_reentrant_dyn_push_copy</a>(runtime_type&lt;&gt;::make&lt;double&gt;(), &amp;pi);</div><div class="line">    assert(queue.<a class="code" href="classdensity_1_1heter__queue.html#ab863df8ed6316860117a6bf26e131bbd">empty</a>()); <span class="comment">// the queue is still empty, because no transaction has been committed</span></div><div class="line"></div><div class="line">    <span class="comment">// commit and start consuming &quot;Hello world!&quot;</span></div><div class="line">    put_2.<a class="code" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html#a96491d550e91a5918050bfdafe43a72c">commit</a>();</div><div class="line">    <span class="keyword">auto</span> consume2 = queue.<a class="code" href="classdensity_1_1heter__queue.html#af139b5f22f2d241df4e26e8da9d95f4d">try_start_reentrant_consume</a>();</div><div class="line">    assert(!consume2.empty() &amp;&amp; consume2.complete_type().is&lt;std::string&gt;());</div><div class="line"></div><div class="line">    <span class="comment">// commit and start consuming 1</span></div><div class="line">    put_1.commit();</div><div class="line">    <span class="keyword">auto</span> consume1 = queue.<a class="code" href="classdensity_1_1heter__queue.html#af139b5f22f2d241df4e26e8da9d95f4d">try_start_reentrant_consume</a>();</div><div class="line">    assert(!consume1.empty() &amp;&amp; consume1.complete_type().is&lt;<span class="keywordtype">int</span>&gt;());</div><div class="line"></div><div class="line">    <span class="comment">// cancel 3.14, and commit the consumes</span></div><div class="line">    put_3.cancel();</div><div class="line">    consume1.commit();</div><div class="line">    consume2.commit();</div><div class="line">    assert(queue.<a class="code" href="classdensity_1_1heter__queue.html#ab863df8ed6316860117a6bf26e131bbd">empty</a>());</div><div class="line"></div></div><!-- fragment --><p> A value in the queue has the type <code>std::pair&lt;const RUNTIME_TYPE &amp;, COMMON_TYPE* const&gt;</code>. Iterators are conceptually pointers to such pairs. They don't provide the multipass guarantee, so they are not <a href="http://en.cppreference.com/w/cpp/concept/ForwardIterator">Forward Iterators</a>, but just <a href="http://en.cppreference.com/w/cpp/concept/InputIterator">Input Iterators</a>. For this reason <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> is not a container. Insertions invalidate no iterators. Removals invalidate only the iterators pointing to the element being removed. Past-the-end iterators are never invalidated, and they compare equal each other and with a default constructed iterator:</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue_1, queue_2;</div><div class="line">    queue_1.push(42);</div><div class="line">    assert(queue_1.end() == queue_2.end() &amp;&amp; queue_1.end() == heter_queue&lt;&gt;::const_iterator() );</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp; value : queue_1)</div><div class="line">    {</div><div class="line">        assert(value.first.is&lt;<span class="keywordtype">int</span>&gt;());</div><div class="line">        assert(*static_cast&lt;int*&gt;(value.second) == 42);</div><div class="line">        *<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(value.second) = 0;</div><div class="line">    }</div></div><!-- fragment --><p> The following table is a summary of the put functions. Functions containing <code>dyn_</code> in their name allow to put an element whose type is not known at compile type (they take as first argument an object of type <code>RUNTIME_TYPE</code>). </p><a class="anchor" id="multi_row"></a>
<table class="doxtable">
<caption>Put functions</caption>
<tr>
<th style="width:400px">Group </th><th>Functions </th><th style="width:130px">Type binding </th><th style="width:130px">Constructor  </th></tr>
<tr>
<td>[start_][reentrant_]push </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a>, <a class="code" href="classdensity_1_1heter__queue.html#abd4493f55adeab87efb382c118066a2e">reentrant_push</a>, <a class="code" href="classdensity_1_1heter__queue.html#a857a56adb973d294e1cf85acca8efbad">start_push</a>, <a class="code" href="classdensity_1_1heter__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a> </div></div><!-- fragment --> </td><td>Compile time </td><td>Copy/Move  </td></tr>
<tr>
<td>[start_][reentrant_]emplace </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">emplace</a>, <a class="code" href="classdensity_1_1heter__queue.html#a99a0cef94c1cde53cf68ce8c11bbc74f">reentrant_emplace</a>, <a class="code" href="classdensity_1_1heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">start_emplace</a>, <a class="code" href="classdensity_1_1heter__queue.html#a6aa035e6311be7c63c72334427572193">start_reentrant_emplace</a> </div></div><!-- fragment --> </td><td>Compile time </td><td>Any  </td></tr>
<tr>
<td>[start_][reentrant_]dyn_push </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">dyn_push</a>, <a class="code" href="classdensity_1_1heter__queue.html#a22a0faba214d7f09f7af2d8ee795490d">reentrant_dyn_push</a>, <a class="code" href="classdensity_1_1heter__queue.html#a65085a9e9c299f23ad95b297752d3775">start_dyn_push</a>, <a class="code" href="classdensity_1_1heter__queue.html#a298d63c59edac31a0d50efc67bdd9381">start_reentrant_dyn_push</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Default  </td></tr>
<tr>
<td>[start_][reentrant_]dyn_push_copy </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1heter__queue.html#a52867536308877c33bfb29f5ca8c9ebc">dyn_push_copy</a>, <a class="code" href="classdensity_1_1heter__queue.html#a09fc9a353af5e0de17d9cd2c74876c3f">reentrant_dyn_push_copy</a>, <a class="code" href="classdensity_1_1heter__queue.html#aac2746c80dae973ad196b7f12c1bbcc8">start_dyn_push_copy</a>, <a class="code" href="classdensity_1_1heter__queue.html#a55249c74018c4dad488fb1eebec8bde3">start_reentrant_dyn_push_copy</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Copy  </td></tr>
<tr>
<td>[start_][reentrant_]dyn_push_move </td><td><div class="fragment"><div class="line"><a class="code" href="classdensity_1_1heter__queue.html#a8da90ba09177e403d9bd6f466d332eca">dyn_push_move</a>, <a class="code" href="classdensity_1_1heter__queue.html#a711a4f42d9c13317c6a1412686c42609">reentrant_dyn_push_move</a>, <a class="code" href="classdensity_1_1heter__queue.html#a194977988482bd3bcfeb92c14ccef60a">start_dyn_push_move</a>, <a class="code" href="classdensity_1_1heter__queue.html#af6abd47f0a85b6d2f90de584c05270c0">start_reentrant_dyn_push_move</a> </div></div><!-- fragment --> </td><td>Runtime </td><td>Move  </td></tr>
</table>
<h2>Implementation and performance notes </h2>
<p>An <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> is basically composed by an ordered set of pages (whose size is determined by the allocator), an <em>head pointer</em> and <em>tail pointer</em>. The first page is the <em>head page</em>, that is the one that contains the address the head pointer points to. The last page is the <em>tail page</em>, that is the one that contains the address the tail pointer points to.</p>
<p>Values are allocated linearly in the memory pages as tightly as the alignment requirements allow. A value is allocated in the queue by adding its size to the tail pointer. The memory layout of a value is composed by:</p><ul>
<li>a <em>ControlBlock</em>, an internal structure composed by an uintptr_t that contains keeps the end address of next value and some internal bit flags. If <code>COMMON_TYPE</code> is not void, the ControlBlock contains also a pointer to the subobject of type COMMON_TYPE of the element.</li>
<li>the <code>RUNTIME_TYPE</code> object. If <code>RUNTIME_TYPE</code>is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a>, this is just a pointer to a pseudo v-table.</li>
<li>the element</li>
</ul>
<p>When a page overflow occurs, a new page is requested to the allocator. Whenever a value is too large to fit in a page, it is allocated outside the pages, with a legacy allocation. Raw memory blocks are allocated in the same way of values, with the difference that they don't have a runtime type associated.</p>
<p>When a value is consumed, its size is added to the head pointer. Pages are not recycled: when the last value of a page is consumed (that is the head moves to another page), the empty page is deallocated. The default allocator, that is <a class="el" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>, is designed to handle efficiently page allocations and deallocations.</p>
<p>Values are never moved by the queue, and are copied only in case of copy-construction or copy assignment of the queue.</p>
<p>Notes:</p>
<ul>
<li>non-reentrant operations may be faster than reentrant</li>
<li>Transactional operations are not slower than non-transactional ones</li>
<li>Typed put operations (like <a class="el" href="classdensity_1_1heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">push</a>) are faster than dynamic puts (like <a class="el" href="classdensity_1_1heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">dyn_push</a>), because they can do some computations at compile time, and because they don't use the <code>RUNTIME_TYPE</code> to construct the element. </li>
</ul>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a9c23132776e1a22b999040f3566bb678"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. The allocator is default-constructed.</p>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: nothing. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory and never throws.</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    assert(queue.empty());</div><div class="line">    assert(std::distance(queue.begin(), queue.end()) == 0);</div><div class="line">    assert(queue.cbegin() == queue.cend());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af29d98e4a12f62328d46386aa469d504"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const ALLOCATOR_TYPE &amp;&#160;</td>
          <td class="paramname"><em>i_source_allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with allocator parameter. The allocator is copy-constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source_allocator</td><td>source used to copy-construct the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: whatever the copy constructor of the allocator throws. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory. It throws anything the copy constructor of the allocator throws.</p>
<div class="fragment"><div class="line">    <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a> allocator;</div><div class="line">    heter_queue&lt;&gt; queue(allocator);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a400becac15c51a0aa865c34162c48eb7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype">ALLOCATOR_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source_allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor with allocator parameter. The allocator is move-constructed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source_allocator</td><td>source used to move-construct the allocator.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: whatever the move constructor of the allocator throws. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). <br />
 <em>Implementation notes</em>: This constructor does not allocate memory. It throws anything the move constructor of the allocator throws.</p>
<div class="fragment"><div class="line">    <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a> allocator;</div><div class="line">    heter_queue&lt;&gt; queue(std::move(allocator));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1b1139d294569f6ffe93170c316be9ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. The allocator is move-constructed from the one of the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move the elements from. After the call the source is left in some valid but indeterminate state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: constant. <br />
 <b>Throws</b>: nothing. <br />
 <em>Implementation notes</em>:</p><ul>
<li>After the call the source is left empty.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, equals&gt;&gt;;</div><div class="line"></div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line">    queue.push(std::string());</div><div class="line">    queue.push(std::make_pair(4., 1));</div><div class="line"></div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue_1(std::move(queue));</div><div class="line"></div><div class="line">    assert(queue.empty());</div><div class="line">    assert(std::distance(queue.begin(), queue.end()) == 0);</div><div class="line">    assert(queue.cbegin() == queue.cend());</div><div class="line"></div><div class="line">    assert(!queue_1.empty());</div><div class="line">    assert(std::distance(queue_1.begin(), queue_1.end()) == 2);</div><div class="line">    assert(queue_1.cbegin() != queue_1.cend());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abbcb0b90dd090a2b5850fd799e33b549"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. The allocator is copy-constructed from the one of the source.</p>
<p><br />
 <b>Requires</b>:</p><ul>
<li>the runtime type must support the feature <a class="el" href="structdensity_1_1type__features_1_1copy__construct.html">type_features::copy_construct</a></li>
</ul>
<p><b>Complexity</b>: linear in the number of elements of the source. <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, equals&gt;&gt;;</div><div class="line"></div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line">    queue.push(std::string());</div><div class="line">    queue.push(std::make_pair(4., 1));</div><div class="line"></div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue_1(queue);</div><div class="line">    assert(queue == queue_1);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a4fbfbfd87e69190da4a54f952f9ea20f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor.</p>
<p><b>Complexity</b>: linear. <br />
 <b>Effects on iterators</b>: any iterator pointing to this queue is invalidated. <br />
 <b>Throws</b>: Nothing. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab61545ab5341627323a3d71121930b7a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment. The allocator is move-assigned from the one of the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move the elements from. After the call the source is left in some valid but indeterminate state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Effects on iterators</b>: Any iterator pointing to this queue or to the source queue is invalidated. <br />
 <b>Throws</b>: Nothing.</p>
<p><br />
 <em>Implementation notes</em>:</p><ul>
<li>After the call the source is left empty.</li>
<li>The complexity is linear in the number of elements in this queue.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, equals&gt;&gt;;</div><div class="line"></div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line">    queue.push(std::string());</div><div class="line">    queue.push(std::make_pair(4., 1));</div><div class="line"></div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue_1;</div><div class="line">    queue_1 = std::move(queue);</div><div class="line"></div><div class="line">    assert(queue.empty());</div><div class="line">    assert(std::distance(queue.begin(), queue.end()) == 0);</div><div class="line">    assert(queue.cbegin() == queue.cend());</div><div class="line"></div><div class="line">    assert(!queue_1.empty());</div><div class="line">    assert(std::distance(queue_1.begin(), queue_1.end()) == 2);</div><div class="line">    assert(queue_1.cbegin() != queue_1.cend());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3c36a623ab4dad8d3c9e36b48feb3463"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment. The allocator is copy-assigned from the one of the source. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>source to move the elements from. After the call the source is left in some valid but indeterminate state.</td></tr>
  </table>
  </dd>
</dl>
<p><b>Complexity</b>: linear. <br />
 <b>Effects on iterators</b>: Any iterator pointing to this queue is invalidated. <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<div class="fragment"><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, copy_construct, destroy, size, alignment, equals&gt;&gt;;</div><div class="line"></div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line">    queue.push(std::string());</div><div class="line">    queue.push(std::make_pair(4., 1));</div><div class="line"></div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue_1;</div><div class="line">    queue_1 = queue;</div><div class="line">    assert(queue == queue_1);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac29f19b7f4021ce4a40e84ab895ab453"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a copy of the allocator</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    assert(queue.get_allocator() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab6418bf0426ef570443a93d4456fa523"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">allocator_type&amp; get_allocator_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the allocator</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    assert(queue.get_allocator_ref() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a15eaf0df4f1d8976f3e799f796dc6f7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const allocator_type&amp; get_allocator_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the allocator</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> &amp; queue_ref = queue;</div><div class="line">    assert(queue_ref.get_allocator_ref() == <a class="code" href="namespacedensity.html#a06c6ce21f0d3cede79e2b503a90b731e">void_allocator</a>());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab863df8ed6316860117a6bf26e131bbd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the queue contains no elements.</p>
<p><b>Complexity</b>: Unspecified. <br />
 <b>Throws</b>: Nothing.</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    assert(queue.empty());</div><div class="line">    queue.push(1);</div><div class="line">    assert(!queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a03bfacfaaba9195e4498375659f43531"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all the elements in the queue.</p>
<p><b>Complexity</b>: linear. <br />
 <b>Effects on iterators</b>: any iterator is invalidated <br />
 <b>Throws</b>: Nothing.</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    queue.push(1);</div><div class="line">    queue.clear();</div><div class="line">    assert(queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae79645ce0f8c0616bbfda669fa6fbadf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>object to be used as source to construct of new element.<ul>
<li>If this argument is an l-value, the new element copy-constructed</li>
<li>If this argument is an r-value, the new element move-constructed</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be copy constructible (in case of l-value) or move constructible (in case of r-value)</li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    queue.push(12);</div><div class="line">    queue.push(std::string(<span class="stringliteral">&quot;Hello world!!&quot;</span>));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a49d0820906b9bd4c1b5a1b08980a9330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 <em>Note</em>: the template argument ELEMENT_TYPE can't be deduced from the parameters so it must explicitly specified.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_construction_params</td><td>construction parameters for the new element.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be constructible with <code>std::forward&lt;CONSTRUCTION_PARAMS&gt;(i_construction_params)...</code></li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    queue.emplace&lt;<span class="keywordtype">int</span>&gt;();</div><div class="line">    queue.emplace&lt;std::string&gt;(12, <span class="charliteral">&#39;-&#39;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a94888fab06d0078cd93ac1562fcce9bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue an element of a type known at runtime, default-constructing it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::default_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>default_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">    queue.dyn_push(type); <span class="comment">// appends 0</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a52867536308877c33bfb29f5ca8c9ebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Appends at the end of the queue an element of a type known at runtime, copy-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type <code>COMMON_TYPE</code> of an object or subobject of type <code>ELEMENT_TYPE</code>. <em>Note</em>: be careful using void pointers: only the compiler knows how to casts from/to a base to/from a derived class.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::copy_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>copy_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    queue.dyn_push_copy(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8da90ba09177e403d9bd6f466d332eca"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue an element of a type known at runtime, move-constructing it from the source.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type <code>COMMON_TYPE</code> of an object or subobject of type <code>ELEMENT_TYPE</code> <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language.</td></tr>
  </table>
  </dd>
</dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li>The function <code>RUNTIME_TYPE::move_construct</code> must be invokable. If <code>RUNTIMETYPE</code> is <a class="el" href="classdensity_1_1runtime__type.html">runtime_type</a> this means that <code>move_construct</code> must be included in the feature list.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    queue.dyn_push_move(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a857a56adb973d294e1cf85acca8efbad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; start_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source. <br />
 This function allocates the required space, constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_source</td><td>object to be used as source to construct of new element.<ul>
<li>If this argument is an l-value, the new element copy-constructed.</li>
<li>If this argument is an r-value, the new element move-constructed. </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be copy constructible (in case of l-value) or move constructible (in case of r-value)</li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> put = queue.start_push(12);</div><div class="line">    put.element() += 2;</div><div class="line">    put.commit(); <span class="comment">// commits a 14</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a722ecea4d64dc7853d3825f24f316b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a>&lt;ELEMENT_TYPE&gt; start_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 This function allocates the required space, constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_construction_params</td><td>construction parameters for the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><br />
 <b>Requires</b>:</p><ul>
<li><code>ELEMENT_TYPE</code> must be constructible with <code>std::forward&lt;CONSTRUCTION_PARAMS&gt;(i_construction_params)...</code></li>
<li><code>ELEMENT_TYPE *</code> must be implicitly convertible <code>COMMON_TYPE *</code></li>
<li><code>COMMON_TYPE *</code> must be convertible to <code>ELEMENT_TYPE *</code> with a static_cast or a dynamic_cast. <br />
 This requirement is not met for example if <code>COMMON_TYPE</code> is a non-polymorphic direct or indirect virtual base of <code>ELEMENT_TYPE</code>.</li>
</ul>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> put = queue.start_emplace&lt;std::string&gt;(4, <span class="charliteral">&#39;*&#39;</span>);</div><div class="line">    put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">    put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65085a9e9c299f23ad95b297752d3775"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, default-constructing it. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_dyn_push(type);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aac2746c80dae973ad196b7f12c1bbcc8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, copy-constructing it from the source.. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type COMMON_TYPE of an object or subobject of type ELEMENT_TYPE. <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_dyn_push_copy(type, &amp;source);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a194977988482bd3bcfeb92c14ccef60a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1put__transaction.html">put_transaction</a> start_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type known at runtime, move-constructing it from the source.. <br />
 This function allocates space for and constructs the new element, and returns a transaction object that may be used to allocate raw space associated to the element being inserted, or to alter the element in some way. <br />
 Call the member function commit on the returned transaction in order to make the effects observable. If the transaction is destroyed before commit has been called, the transaction is canceled and it has no observable effects. Until the returned transaction is committed or canceled, the queue is not in a consistent state. If any function is called in this timespan, the behavior is undefined.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_type</td><td>type of the new element. </td></tr>
    <tr><td class="paramname">i_source</td><td>pointer to the subobject of type COMMON_TYPE of an object or subobject of type ELEMENT_TYPE. <em>Note</em>: be careful using void pointers: casts from/to a base to/from a derived class can be done only by the type system of the language. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The associated transaction object.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: no iterator is invalidated <br />
 <b>Throws</b>: unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_dyn_push_move(type, &amp;source);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a274dca2a1d2c68ff3249f37b3ae410d5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<p>This function is equivalent to:</p>
<p><code><a class="el" href="classdensity_1_1heter__queue.html#ac6f1ab782b6edf567268eee5613c82d1">try_start_consume()</a>.commit(); </code></p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if the queue is empty.</dd></dl>
<p><b>Complexity</b>: constant <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    queue.push(1);</div><div class="line">    queue.push(2);</div><div class="line"></div><div class="line">    queue.pop();</div><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_consume();</div><div class="line">    assert(consume.element&lt;<span class="keywordtype">int</span>&gt;() == 2);</div><div class="line">    consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a35b9c85fad7f5d27b7555c29b2e4e3fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue, if the queue is not empty. Otherwise it has no effect. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>whether an element was actually removed.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing </p><div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> pop_result = queue.try_pop();</div><div class="line">    assert(pop_result == <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    queue.push(1);</div><div class="line">    queue.push(2);</div><div class="line"></div><div class="line">    pop_result = queue.try_pop();</div><div class="line">    assert(pop_result == <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_consume();</div><div class="line">    assert(consume.element&lt;<span class="keywordtype">int</span>&gt;() == 2);</div><div class="line">    consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac6f1ab782b6edf567268eee5613c82d1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> try_start_consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation. </p><dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> which is empty if there are no elements to consume</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consume_1 = queue.try_start_consume();</div><div class="line">    assert(!consume_1);</div><div class="line"></div><div class="line">    queue.push(42);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consume_2 = queue.try_start_consume();</div><div class="line">    assert(consume_2);</div><div class="line">    assert(consume_2.element&lt;<span class="keywordtype">int</span>&gt;() == 42);</div><div class="line">    consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a616b75e28b72dcb69afe98280ad561e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_start_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> &amp;&#160;</td>
          <td class="paramname"><em>i_consume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation using an existing <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> object. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_consume</td><td>reference to a <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> to be used. If it is non-empty it gets canceled before trying to start the new consume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether i_consume is non-empty after the call, that is whether the queue was not empty.</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<p>This overload is similar to the one taking no arguments and returning a <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a>. For an <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> there is no performance difference between the two overloads. Anyway for lock-free concurrent queue this overload may be faster.</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    heter_queue&lt;&gt;::consume_operation consume_1;</div><div class="line">    <span class="keywordtype">bool</span> <span class="keyword">const</span> bool_1 = queue.try_start_consume(consume_1);</div><div class="line">    assert(!bool_1 &amp;&amp; !consume_1);</div><div class="line"></div><div class="line">    queue.push(42);</div><div class="line"></div><div class="line">    heter_queue&lt;&gt;::consume_operation consume_2;</div><div class="line">    <span class="keyword">auto</span> bool_2 = queue.try_start_consume(consume_2);</div><div class="line">    assert(consume_2 &amp;&amp; bool_2);</div><div class="line">    assert(consume_2.element&lt;<span class="keywordtype">int</span>&gt;() == 42);</div><div class="line">    consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abd4493f55adeab87efb382c118066a2e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">heter_queue::push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    queue.reentrant_push(12);</div><div class="line">    queue.reentrant_push(std::string(<span class="stringliteral">&quot;Hello world!!&quot;</span>));</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99a0cef94c1cde53cf68ce8c11bbc74f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">heter_queue::emplace</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    queue.reentrant_emplace&lt;<span class="keywordtype">int</span>&gt;();</div><div class="line">    queue.reentrant_emplace&lt;std::string&gt;(12, <span class="charliteral">&#39;-&#39;</span>);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a22a0faba214d7f09f7af2d8ee795490d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#a94888fab06d0078cd93ac1562fcce9bf">heter_queue::dyn_push</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">    queue.reentrant_dyn_push(type); <span class="comment">// appends 0</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a09fc9a353af5e0de17d9cd2c74876c3f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#a52867536308877c33bfb29f5ca8c9ebc">heter_queue::dyn_push_copy</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    queue.reentrant_dyn_push_copy(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a711a4f42d9c13317c6a1412686c42609"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#a8da90ba09177e403d9bd6f466d332eca">heter_queue::dyn_push_move</a>, but allows reentrancy: during the construction of the element the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    queue.reentrant_dyn_push_move(type, &amp;source);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a43e3c73b2740ce46477422fb90d18208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; start_reentrant_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#a857a56adb973d294e1cf85acca8efbad">heter_queue::start_push</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_push(12);</div><div class="line">    put.element() += 2;</div><div class="line">    put.commit(); <span class="comment">// commits a 14</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6aa035e6311be7c63c72334427572193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a>&lt;ELEMENT_TYPE&gt; start_reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">heter_queue::start_emplace</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_emplace&lt;std::string&gt;(4, <span class="charliteral">&#39;*&#39;</span>);</div><div class="line">    put.element() += <span class="stringliteral">&quot;****&quot;</span>;</div><div class="line">    put.commit(); <span class="comment">// commits a &quot;********&quot;</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a298d63c59edac31a0d50efc67bdd9381"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#a65085a9e9c299f23ad95b297752d3775">heter_queue::start_dyn_push</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;default_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;int&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push(type);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a55249c74018c4dad488fb1eebec8bde3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push_copy </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#aac2746c80dae973ad196b7f12c1bbcc8">heter_queue::start_dyn_push_copy</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;copy_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string <span class="keyword">const</span> source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push_copy(type, &amp;source);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af6abd47f0a85b6d2f90de584c05270c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__put__transaction.html">reentrant_put_transaction</a> start_reentrant_dyn_push_move </td>
          <td>(</td>
          <td class="paramtype">const runtime_type &amp;&#160;</td>
          <td class="paramname"><em>i_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">COMMON_TYPE *&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same to <a class="el" href="classdensity_1_1heter__queue.html#a194977988482bd3bcfeb92c14ccef60a">heter_queue::start_dyn_push_move</a>, but allows reentrancy: during the construction of the element, and until the state of the transaction gets destroyed, the queue is in a valid state.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">    <span class="keyword">using namespace </span>type_features;</div><div class="line">    <span class="keyword">using</span> MyRunTimeType = runtime_type&lt;void, feature_list&lt;move_construct, destroy, size, alignment&gt;&gt;;</div><div class="line">    heter_queue&lt;void, MyRunTimeType&gt; queue;</div><div class="line"></div><div class="line">    std::string source(<span class="stringliteral">&quot;Hello world!!&quot;</span>);</div><div class="line">    <span class="keyword">auto</span> <span class="keyword">const</span> type = MyRunTimeType::make&lt;decltype(source)&gt;();</div><div class="line">    <span class="keyword">auto</span> put = queue.start_reentrant_dyn_push_move(type, &amp;source);</div><div class="line">    put.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa83c43fd2aca56043d4209f67dd579a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue. This is the reentrant version of pop. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<p>This function is equivalent to:</p>
<p><code><a class="el" href="classdensity_1_1heter__queue.html#af139b5f22f2d241df4e26e8da9d95f4d">try_start_reentrant_consume()</a>.commit(); </code></p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if the queue is empty.</dd></dl>
<p><b>Complexity</b>: constant <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line">    queue.push(1);</div><div class="line">    queue.push(2);</div><div class="line"></div><div class="line">    queue.reentrant_pop();</div><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_consume();</div><div class="line">    assert(consume.element&lt;<span class="keywordtype">int</span>&gt;() == 2);</div><div class="line">    consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac83d6e59ab5dec61205db0cea6e6cf5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes and destroy the first element of the queue, if the queue is not empty. Otherwise it has no effect. This is the reentrant version of try_pop. This function discards the element. Use a consume function if you want to access the element before it gets destroyed.</p>
<dl class="section return"><dt>Returns</dt><dd>whether an element was actually removed.</dd></dl>
<p><b>Complexity</b>: constant. <br />
 <b>Effects on iterators</b>: any iterator pointing to the first element is invalidated <br />
 <b>Throws</b>: nothing </p><div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> pop_result = queue.try_reentrant_pop();</div><div class="line">    assert(pop_result == <span class="keyword">false</span>);</div><div class="line"></div><div class="line">    queue.push(1);</div><div class="line">    queue.push(2);</div><div class="line"></div><div class="line">    pop_result = queue.try_reentrant_pop();</div><div class="line">    assert(pop_result == <span class="keyword">true</span>);</div><div class="line">    <span class="keyword">auto</span> consume = queue.try_start_reentrant_consume();</div><div class="line">    assert(consume.element&lt;<span class="keywordtype">int</span>&gt;() == 2);</div><div class="line">    consume.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af139b5f22f2d241df4e26e8da9d95f4d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> try_start_reentrant_consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a reentrant consume operation. This is the reentrant version of try_start_consume.</p>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> which is empty if there are no elements to consume</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consume_1 = queue.try_start_reentrant_consume();</div><div class="line">    assert(!consume_1);</div><div class="line"></div><div class="line">    queue.push(42);</div><div class="line"></div><div class="line">    <span class="keyword">auto</span> consume_2 = queue.try_start_reentrant_consume();</div><div class="line">    assert(consume_2);</div><div class="line">    assert(consume_2.element&lt;<span class="keywordtype">int</span>&gt;() == 42);</div><div class="line">    consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aab0a2b3d02d22ceb03b4bf8efdf13d47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_start_reentrant_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue_1_1reentrant__consume__operation.html">reentrant_consume_operation</a> &amp;&#160;</td>
          <td class="paramname"><em>i_consume</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to start a consume operation using an existing <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> object. This is the reentrant version of try_start_consume.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_consume</td><td>reference to a <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a> to be used. If it is non-empty it gets canceled before trying to start the new consume. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether i_consume is non-empty after the call, that is whether the queue was not empty.</dd></dl>
<p>A non-empty consume must be committed for the consume to have effect.</p>
<p>This overload is similar to the one taking no arguments and returning a <a class="el" href="classdensity_1_1heter__queue_1_1consume__operation.html">consume_operation</a>. For an <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> there is no performance difference between the two overloads. Anyway for lock-free concurrent queue this overload may be faster.</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue;</div><div class="line"></div><div class="line">    heter_queue&lt;&gt;::reentrant_consume_operation consume_1;</div><div class="line">    <span class="keywordtype">bool</span> <span class="keyword">const</span> bool_1 = queue.try_start_reentrant_consume(consume_1);</div><div class="line">    assert(!bool_1 &amp;&amp; !consume_1);</div><div class="line"></div><div class="line">    queue.push(42);</div><div class="line"></div><div class="line">    heter_queue&lt;&gt;::reentrant_consume_operation consume_2;</div><div class="line">    <span class="keyword">auto</span> bool_2 = queue.try_start_reentrant_consume(consume_2);</div><div class="line">    assert(consume_2 &amp;&amp; bool_2);</div><div class="line">    assert(consume_2.element&lt;<span class="keywordtype">int</span>&gt;() == 42);</div><div class="line">    consume_2.commit();</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a455b06c26dd46d98bf859b924719e657"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this queue and another queue compare equal. Two <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> are equal if:</p><ul>
<li>they have the same number of elements</li>
<li>the i-th RUNTIME_TYPE in the first queue is equal to the i-th RUNTIME_TYPE in the second queue</li>
<li>the i-th element in the first queue is equal to the i-th element in the second queue</li>
</ul>
<p>Raw block are not relevant for comparison. </p><pre class="fragment">&lt;b&gt;Requires&lt;/b&gt;:
    - the runtime type must support the feature &lt;code&gt;type_features::are_equal&lt;/code&gt;

&lt;b&gt;Complexity&lt;/b&gt;: linear in the number of elements
\n &lt;b&gt;Throws&lt;/b&gt;: unspecified.
\n &lt;b&gt;Exception guarantee&lt;/b&gt;: strong (in case of exception the function has no observable effects).  </pre> 
</div>
</div>
<a class="anchor" id="ab104611a8554c4ee98ff653b8defc6ef"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this queue and another queue does not compare equal. Two <a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a> are equal if:</p><ul>
<li>they have the same number of elements</li>
<li>the i-th RUNTIME_TYPE in the first queue is equal to the i-th RUNTIME_TYPE in the second queue</li>
<li>the i-th element in the first queue is equal to the i-th element in the second queue</li>
</ul>
<p>Raw block are not relevant for comparison. </p><pre class="fragment">&lt;b&gt;Requires&lt;/b&gt;:
    - the runtime type must support the feature &lt;code&gt;type_features::are_equal&lt;/code&gt;

&lt;b&gt;Complexity&lt;/b&gt;: linear in the number of elements
\n &lt;b&gt;Throws&lt;/b&gt;: unspecified.
\n &lt;b&gt;Exception guarantee&lt;/b&gt;: strong (in case of exception the function has no observable effects).  </pre> 
</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a2685ae9e207561c284a1d61e28572156"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdensity_1_1heter__queue.html">heter_queue</a>&lt; COMMON_TYPE, RUNTIME_TYPE, ALLOCATOR_TYPE &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps two queues.</p>
<div class="fragment"><div class="line">    heter_queue&lt;&gt; queue, queue_1;</div><div class="line">    queue.push(1);</div><div class="line">    <a class="code" href="classdensity_1_1heter__queue.html#a2685ae9e207561c284a1d61e28572156">swap</a>(queue, queue_1);</div><div class="line"></div><div class="line">    assert(queue.empty());</div><div class="line">    assert(std::distance(queue.begin(), queue.end()) == 0);</div><div class="line">    assert(queue.cbegin() == queue.cend());</div><div class="line"></div><div class="line">    assert(!queue_1.empty());</div><div class="line">    assert(std::distance(queue_1.begin(), queue_1.end()) == 1);</div><div class="line">    assert(queue_1.cbegin() != queue_1.cend());</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a2cdcdcfbd2342ad05b1c907bfaf76703"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t min_alignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= detail::size_max(detail::Queue_AllFlags + 1,</div><div class="line">            <span class="keyword">alignof</span>(ControlBlock), <span class="keyword">alignof</span>(RUNTIME_TYPE))</div></div><!-- fragment --><p>Minimum guaranteed alignment for every element. The actual alignment of an element may be stricter if the type requires it. </p>

</div>
</div>
<a class="anchor" id="a58697d487018a8bde47d4c274c7bd76a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_puts = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether multiple threads can do put operations on the same queue without any further synchronization. </p>

</div>
</div>
<a class="anchor" id="a2e2bd4f332d922d3024a4bb65f9d17e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_consumes = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether multiple threads can do consume operations on the same queue without any further synchronization. </p>

</div>
</div>
<a class="anchor" id="a30744c14b0233cd7f55466ff04151aa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_put_consumes = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether puts and consumes can be done concurrently without any further synchronization. In any case unsynchronized concurrency is constrained by concurrent_puts and concurrent_consumes. </p>

</div>
</div>
<a class="anchor" id="a7708a88b67261ef454d875047bcfa79d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool is_seq_cst = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this queue is sequential consistent. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/density/density/<a class="el" href="heter__queue_8h_source.html">heter_queue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
