<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>density: basic_default_allocator&lt; PAGE_CAPACITY_AND_ALIGNMENT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">density
   </div>
   <div id="projectbrief">C++11 library for paged memory management, function queues, heterogeneous queues and lifo memory management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedensity.html">density</a></li><li class="navelem"><a class="el" href="classdensity_1_1basic__default__allocator.html">basic_default_allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classdensity_1_1basic__default__allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">basic_default_allocator&lt; PAGE_CAPACITY_AND_ALIGNMENT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="default__allocator_8h_source.html">default_allocator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1d56b32852c92c13ceee61989b4bb2c1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a1d56b32852c92c13ceee61989b4bb2c1">allocate</a> (size_t i_size, size_t i_alignment, size_t i_alignment_offset=0)</td></tr>
<tr class="separator:a1d56b32852c92c13ceee61989b4bb2c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c898a5fb8e8e83ce71d29cfe112a9d4"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a0c898a5fb8e8e83ce71d29cfe112a9d4">try_allocate</a> (size_t i_size, size_t i_alignment, size_t i_alignment_offset=0) noexcept</td></tr>
<tr class="separator:a0c898a5fb8e8e83ce71d29cfe112a9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8f30ff0beeb7294e468d41ff237af0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a2d8f30ff0beeb7294e468d41ff237af0">deallocate</a> (void *i_block, size_t i_size, size_t i_alignment, size_t i_alignment_offset=0) noexcept</td></tr>
<tr class="separator:a2d8f30ff0beeb7294e468d41ff237af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dadf0ba1be0f3add753fd43c4dfa7cf"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a9dadf0ba1be0f3add753fd43c4dfa7cf">allocate_page</a> ()</td></tr>
<tr class="separator:a9dadf0ba1be0f3add753fd43c4dfa7cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1832bfeccfd0dd8c83a5176102c179"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a0f1832bfeccfd0dd8c83a5176102c179">try_allocate_page</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee) noexcept</td></tr>
<tr class="separator:a0f1832bfeccfd0dd8c83a5176102c179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9c8b93dc09ad967c399d4031a82b592"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#ab9c8b93dc09ad967c399d4031a82b592">allocate_page_zeroed</a> ()</td></tr>
<tr class="separator:ab9c8b93dc09ad967c399d4031a82b592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21fb05613d21dc9dcb94a80c2295dc7"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#ac21fb05613d21dc9dcb94a80c2295dc7">try_allocate_page_zeroed</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee) noexcept</td></tr>
<tr class="separator:ac21fb05613d21dc9dcb94a80c2295dc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a047dc26511d89527c563027714ec8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a45a047dc26511d89527c563027714ec8">deallocate_page</a> (void *i_page) noexcept</td></tr>
<tr class="separator:a45a047dc26511d89527c563027714ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c4d5fadbf8a599670b7d2b8fdf0c36"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a56c4d5fadbf8a599670b7d2b8fdf0c36">deallocate_page_zeroed</a> (void *i_page) noexcept</td></tr>
<tr class="separator:a56c4d5fadbf8a599670b7d2b8fdf0c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749981d5654301f94a76d285f6795d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a749981d5654301f94a76d285f6795d37">pin_page</a> (void *i_page) noexcept</td></tr>
<tr class="separator:a749981d5654301f94a76d285f6795d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bcc0338d78cf3e8462207134ae05a7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a2bcc0338d78cf3e8462207134ae05a7c">unpin_page</a> (void *i_address) noexcept</td></tr>
<tr class="separator:a2bcc0338d78cf3e8462207134ae05a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e809e7b9ca0804360bcc47c7d42027e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a3e809e7b9ca0804360bcc47c7d42027e">try_pin_page</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, void *i_address) noexcept</td></tr>
<tr class="separator:a3e809e7b9ca0804360bcc47c7d42027e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58f5ddd6ae1288498bc969582d3845dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a58f5ddd6ae1288498bc969582d3845dd">unpin_page</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, void *i_address) noexcept</td></tr>
<tr class="separator:a58f5ddd6ae1288498bc969582d3845dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b6bce364bebcb7482d2a555a6806c4"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#ac7b6bce364bebcb7482d2a555a6806c4">get_pin_count</a> (const void *i_address) noexcept</td></tr>
<tr class="separator:ac7b6bce364bebcb7482d2a555a6806c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751ffc546e503bc9790f87844081f5d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a751ffc546e503bc9790f87844081f5d2">operator==</a> (const <a class="el" href="classdensity_1_1basic__default__allocator.html">basic_default_allocator</a> &amp;) const  noexcept</td></tr>
<tr class="separator:a751ffc546e503bc9790f87844081f5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fec68493af3dd056327303bf2ce9d1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a7fec68493af3dd056327303bf2ce9d1b">operator!=</a> (const <a class="el" href="classdensity_1_1basic__default__allocator.html">basic_default_allocator</a> &amp;) const  noexcept</td></tr>
<tr class="separator:a7fec68493af3dd056327303bf2ce9d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8788211b681a077a7720926cf48ee239"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a8788211b681a077a7720926cf48ee239">reserve_lockfree_page_memory</a> (size_t i_size, size_t *o_reserved_size=nullptr)</td></tr>
<tr class="separator:a8788211b681a077a7720926cf48ee239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac780cf7dd16714173288f14a2c2bf9c8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#ac780cf7dd16714173288f14a2c2bf9c8">try_reserve_lockfree_page_memory</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, size_t i_size, size_t *o_reserved_size=nullptr) noexcept</td></tr>
<tr class="separator:ac780cf7dd16714173288f14a2c2bf9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a932b949644846310184e410bee289d71"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#a932b949644846310184e410bee289d71">page_size</a> = PageAllocator::page_size</td></tr>
<tr class="separator:a932b949644846310184e410bee289d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99402c5b1cdb34949ea2cb0a4867d65"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1basic__default__allocator.html#ad99402c5b1cdb34949ea2cb0a4867d65">page_alignment</a> = PageAllocator::page_alignment</td></tr>
<tr class="separator:ad99402c5b1cdb34949ea2cb0a4867d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;size_t PAGE_CAPACITY_AND_ALIGNMENT = default_page_capacity&gt;<br />
class density::basic_default_allocator&lt; PAGE_CAPACITY_AND_ALIGNMENT &gt;</h3>

<p>Class template providing paged and legacy memory allocation. It models both the <a class="el" href="UntypedAllocator_concept.html">UntypedAllocator</a> and <a class="el" href="PagedAllocator_concept.html">PagedAllocator</a> concepts.</p>
<p><a class="el" href="classdensity_1_1basic__default__allocator.html">basic_default_allocator</a> is stateless, so instances are interchangeable: blocks and pages can be deallocated by any instance of <a class="el" href="classdensity_1_1basic__default__allocator.html">basic_default_allocator</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1d56b32852c92c13ceee61989b4bb2c1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a legacy memory block with the specified size and alignment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size of the requested memory block, in bytes </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment of the requested memory block, in bytes </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset of the block to be aligned, in bytes. The alignment is guaranteed only i_alignment_offset bytes from the beginning of the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the new memory block, always != nullptr</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>i_alignment is zero or it is not an integer power of 2</li>
<li>i_size is not a multiple of i_alignment</li>
<li>i_alignment_offset is greater than i_size</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: the same of the built-in operator new, usually blocking <br />
 <b>Throws</b>: std::bad_alloc on failure</p>
<p>The content of the newly allocated block is undefined. </p>

</div>
</div>
<a class="anchor" id="a0c898a5fb8e8e83ce71d29cfe112a9d4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* try_allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to allocates a legacy memory block with the specified size and alignment. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>size of the requested memory block, in bytes </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment of the requested memory block, in bytes </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset of the block to be aligned, in bytes. The alignment is guaranteed only i_alignment_offset bytes from the beginning of the block. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the new memory block, or nullptr in case of failure</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>i_alignment is zero or it is not an integer power of 2</li>
<li>i_size is not a multiple of i_alignment</li>
<li>i_alignment_offset is greater than i_size</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: the same of the built-in operator new, usually blocking <br />
 <b>Throws</b>: nothing</p>
<p>The content of the newly allocated block is undefined. </p>

</div>
</div>
<a class="anchor" id="a2d8f30ff0beeb7294e468d41ff237af0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_alignment_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocates a legacy memory block. After the call any access to the memory block results in undefined behavior. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_block</td><td>block to deallocate, or nullptr. </td></tr>
    <tr><td class="paramname">i_size</td><td>size of the block to deallocate, in bytes. </td></tr>
    <tr><td class="paramname">i_alignment</td><td>alignment of the memory block. </td></tr>
    <tr><td class="paramname">i_alignment_offset</td><td>offset of the alignment</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>i_block is not a memory block allocated by the function allocate</li>
<li>i_size, i_alignment and i_alignment_offset are not the same specified when the block was allocated</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: the same of the built-in operator delete, usually blocking <br />
 <b>Throws</b>: nothing</p>
<p>If i_block is nullptr, the call has no effect. </p>

</div>
</div>
<a class="anchor" id="a9dadf0ba1be0f3add753fd43c4dfa7cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate_page </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a memory page. </p><dl class="section return"><dt>Returns</dt><dd>address of the new memory page, always != nullptr</dd></dl>
<p><br />
 <b>Progress guarantee</b>: blocking <br />
 <b>Throws</b>: std::bad_alloc on failure.</p>
<p>The content of the newly allocated page is undefined. </p>

</div>
</div>
<a class="anchor" id="a0f1832bfeccfd0dd8c83a5176102c179"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* try_allocate_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to allocates a memory page. </p><dl class="section return"><dt>Returns</dt><dd>address of the new memory page, or nullptr if the allocation fails</dd></dl>
<p><br />
 <b>Progress guarantee</b>: specified by the argument <br />
 <b>Throws</b>: nothing</p>
<p>The content of the newly allocated page is undefined. </p>

</div>
</div>
<a class="anchor" id="ab9c8b93dc09ad967c399d4031a82b592"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate_page_zeroed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a memory page. </p><dl class="section return"><dt>Returns</dt><dd>address of the new memory page, always != nullptr</dd></dl>
<p><br />
 <b>Progress guarantee</b>: blocking <br />
 <b>Throws</b>: std::bad_alloc on failure.</p>
<p>The content of the newly allocated page is zeroed. </p>

</div>
</div>
<a class="anchor" id="ac21fb05613d21dc9dcb94a80c2295dc7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* try_allocate_page_zeroed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to allocates a memory page. </p><dl class="section return"><dt>Returns</dt><dd>address of the new memory page, or nullptr if the allocation fails</dd></dl>
<p><br />
 <b>Progress guarantee</b>: specified by the argument <br />
 <b>Throws</b>: nothing</p>
<p>The content of the newly allocated page is zeroed. </p>

</div>
</div>
<a class="anchor" id="a45a047dc26511d89527c563027714ec8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_page </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocates a memory page. If the page is still pinned by some threads, it is not altered or recycled by the allocator until it is unpinned. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_page</td><td>pointer to a byte within the page to deallocate. Can't be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>i_page is not a page allocated by allocate_page, try_allocate_page, allocate_page_zeroed or try_allocate_page_zeroed</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: wait free <br />
 <b>Throws</b>: nothing </p>

</div>
</div>
<a class="anchor" id="a56c4d5fadbf8a599670b7d2b8fdf0c36"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate_page_zeroed </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocates a memory page. If the page is still pinned by some threads, it is not altered or recycled by the allocator until it is unpinned. If the page is not pinned, it must be zeroed. Otherwise it must be zeroed when the last pin is removed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_page</td><td>pointer to a byte within the page to deallocate. Can't be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>i_page is not a page allocated by allocate_page, try_allocate_page, allocate_page_zeroed or try_allocate_page_zeroed</li>
<li>when the last pin is removed the page is not completely zeroed</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: wait free <br />
 <b>Throws</b>: nothing </p>

</div>
</div>
<a class="anchor" id="a8788211b681a077a7720926cf48ee239"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void reserve_lockfree_page_memory </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>o_reserved_size</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reserves the specified memory size from the system for lock-free page allocation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>the space (in bytes) that the internal page allocator should reserve for page allocation. </td></tr>
    <tr><td class="paramname">o_reserved_size</td><td>pointer to a size_t that receives the actual space (in bytes) that the allocator has allocated from the system, always greater or equal to i_size. This parameter can be null, in which case the actual reserved size is not returned.</td></tr>
  </table>
  </dd>
</dl>
<p>The internal page allocator requests memory regions from the system and uses them to allocate pages with a lock-free algorithm. Regions are returned to the system only during the destruction of global objects. <br />
This function ensures that the sum of the capacity available in the all the regions is at least the specified size. If a new region is necessary in order to reach the specified capacity, but the allocation from the system fails, this function throw a std::bad_alloc. <br />
Note: some of this space may be already allocated as pages.</p>
<p><br />
 <b>Progress guarantee</b>: blocking <br />
 <b>Throws</b>: std::bad_alloc on failure. </p>

</div>
</div>
<a class="anchor" id="ac780cf7dd16714173288f14a2c2bf9c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool try_reserve_lockfree_page_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>o_reserved_size</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to reserve the specified memory size from the system for lock-free page allocation. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_progress_guarantee</td><td>minimum progress guarantee of this call. If it is not progress_blocking, no region is allocated </td></tr>
    <tr><td class="paramname">i_size</td><td>the space (in bytes) that the internal page allocator should reserve for page allocation. </td></tr>
    <tr><td class="paramname">o_reserved_size</td><td>pointer to a size_t that receives the actual space (in bytes) that the allocator has allocated from the system, always greater or equal to i_size. This parameter can be null, in which case the actual reserved size is not returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>whether the requested size is less than or equal to the actual reserved space</dd></dl>
<p>The internal page allocator requests memory regions from the system and uses them to allocate pages. Regions are returned to the system only during the destruction of global objects. <br />
This function verifies that the sum of memory available in the regions is at least the specified size. Note: some of this space may be already allocated as pages.</p>
<p><br />
 <b>Progress guarantee</b>: specified by the argument <br />
 <b>Throws</b>: nothing. </p>

</div>
</div>
<a class="anchor" id="a749981d5654301f94a76d285f6795d37"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void pin_page </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_page</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pins the page containing the specified address, incrementing an internal page_specific ref-count.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_page</td><td>pointer to a byte within the page to deallocate. Can't be nullptr.</td></tr>
  </table>
  </dd>
</dl>
<p>If the page has been already deallocated no undefined behavior occurs: the caller should detect this case and unpin the page immediately. Using a deallocated-then-pinned page in any other way other than unpinning (including accessing its content) causes undefined behavior. <br />
If the page is still allocated then the pin ensures that, while the page is pinned:</p><ul>
<li>the content of the page is not altered by the allocator</li>
<li>the page is not returned by a call to allocate_page, try_allocate_page, allocate_page_zeroed or try_allocate_page_zeroed.</li>
<li>if the page gets deallocated with a call to allocate_page_zeroed or try_allocate_page_zeroed, the memory may be still not zeroed.</li>
</ul>
<p>Every call to pin_page should be matched by a call to unpin_page by the same thread. A thread may pin the same page multiple times, provided that it unpins the page the same number of times.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>the page containing i_page was never returned by allocate_page, try_allocate_page, allocate_page_zeroed or try_allocate_page_zeroed</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: lock-free <br />
 <b>Throws</b>: nothing. </p>

</div>
</div>
<a class="anchor" id="a2bcc0338d78cf3e8462207134ae05a7c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unpin_page </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a pin from the page, decrementing the internal ref-count.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>the page containing i_page was never returned by allocate_page, try_allocate_page, allocate_page_zeroed or try_allocate_page_zeroed</li>
<li>the page was not previously pinned by this thread</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: lock-free <br />
 <b>Throws</b>: nothing. </p>

</div>
</div>
<a class="anchor" id="a3e809e7b9ca0804360bcc47c7d42027e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_pin_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to pin the page containing the specified address, incrementing an internal page_specific ref-count, If the implementation can't complete the action with the specified progress guarantee, the call has no visible effects, and the return value is false. Otherwise the return value is true..</p>
<p><br />
 <b>Progress guarantee</b>: specified by the argument <br />
 <b>Throws</b>: nothing. </p>

</div>
</div>
<a class="anchor" id="a58f5ddd6ae1288498bc969582d3845dd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void unpin_page </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_address</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes a pin from the page, decrementing the internal ref-count.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>the page containing i_page was never returned by allocate_page, try_allocate_page, allocate_page_zeroed or try_allocate_page_zeroed</li>
<li>the page was not previously pinned by this thread</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: specified by the argument <br />
 <b>Throws</b>: nothing. </p>

</div>
</div>
<a class="anchor" id="ac7b6bce364bebcb7482d2a555a6806c4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t get_pin_count </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>i_address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the number of times the specified page has been pinned by any thread. This function is useful only for diagnostic or debugging.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>the page containing i_page was never returned by allocate_page, try_allocate_page, allocate_page_zeroed or try_allocate_page_zeroed</li>
</ul>
</dd></dl>
<p><br />
 <b>Progress guarantee</b>: wait-free <br />
 <b>Throws</b>: nothing. </p>

</div>
</div>
<a class="anchor" id="a751ffc546e503bc9790f87844081f5d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1basic__default__allocator.html">basic_default_allocator</a>&lt; PAGE_CAPACITY_AND_ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the right-side allocator can be used to deallocate block and pages allocated by this allocator. </p><dl class="section return"><dt>Returns</dt><dd>always true. </dd></dl>

</div>
</div>
<a class="anchor" id="a7fec68493af3dd056327303bf2ce9d1b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1basic__default__allocator.html">basic_default_allocator</a>&lt; PAGE_CAPACITY_AND_ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether the right-side allocator cannot be used to deallocate block and pages allocated by this allocator. </p><dl class="section return"><dt>Returns</dt><dd>always false. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a932b949644846310184e410bee289d71"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t page_size = PageAllocator::page_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Usable size (in bytes) of memory pages. </p>

</div>
</div>
<a class="anchor" id="ad99402c5b1cdb34949ea2cb0a4867d65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t page_alignment = PageAllocator::page_alignment</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alignment (in bytes) of memory pages. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/density/density/<a class="el" href="default__allocator_8h_source.html">default_allocator.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
