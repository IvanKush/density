<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>density: sp_function_queue&lt; CALLABLE, ALLOCATOR_TYPE, ERASURE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">density
   </div>
   <div id="projectbrief">C++11 library for paged memory management, function queues, heterogeneous queues and lifo memory management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedensity.html">density</a></li><li class="navelem"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classdensity_1_1sp__function__queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sp_function_queue&lt; CALLABLE, ALLOCATOR_TYPE, ERASURE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sp__function__queue_8h_source.html">sp_function_queue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a0c5a5dbd9e7421267b61f14bbe16e203"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE &gt; </td></tr>
<tr class="memitem:a0c5a5dbd9e7421267b61f14bbe16e203"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a> = typename UnderlyingQueue::template <a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt; ELEMENT_COMPLETE_TYPE &gt;</td></tr>
<tr class="separator:a0c5a5dbd9e7421267b61f14bbe16e203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388fe9f5a77185b531f9133276131bf1"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE &gt; </td></tr>
<tr class="memitem:a388fe9f5a77185b531f9133276131bf1"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a> = typename UnderlyingQueue::template <a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt; ELEMENT_COMPLETE_TYPE &gt;</td></tr>
<tr class="separator:a388fe9f5a77185b531f9133276131bf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f4be9414604d34f18d1ac4c57f7cccc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a5f4be9414604d34f18d1ac4c57f7cccc">consume_operation</a> = typename UnderlyingQueue::consume_operation</td></tr>
<tr class="separator:a5f4be9414604d34f18d1ac4c57f7cccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9808b16fc781b09c2b6389fcbad45ee5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a9808b16fc781b09c2b6389fcbad45ee5">reentrant_consume_operation</a> = typename UnderlyingQueue::reentrant_consume_operation</td></tr>
<tr class="separator:a9808b16fc781b09c2b6389fcbad45ee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad8d4d19008b24c9cb9755d03c977a55a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a> () noexcept=default</td></tr>
<tr class="separator:ad8d4d19008b24c9cb9755d03c977a55a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2c5104bf51635dc3ef1ea90fd679cc5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#ad2c5104bf51635dc3ef1ea90fd679cc5">sp_function_queue</a> (<a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> &amp;&amp;i_source) noexcept=default</td></tr>
<tr class="separator:ad2c5104bf51635dc3ef1ea90fd679cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae853919c01aec9409d9d133f4f25d8c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#ae853919c01aec9409d9d133f4f25d8c8">operator=</a> (<a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> &amp;&amp;i_source) noexcept=default</td></tr>
<tr class="separator:ae853919c01aec9409d9d133f4f25d8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a528c4f64ed579d46ff11156baaadc279"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a528c4f64ed579d46ff11156baaadc279">~sp_function_queue</a> ()</td></tr>
<tr class="separator:a528c4f64ed579d46ff11156baaadc279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16cc74a3c5e9d1f9bf798029df5274a"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE &gt; </td></tr>
<tr class="memitem:ab16cc74a3c5e9d1f9bf798029df5274a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#ab16cc74a3c5e9d1f9bf798029df5274a">push</a> (ELEMENT_COMPLETE_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:ab16cc74a3c5e9d1f9bf798029df5274a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a49d0820906b9bd4c1b5a1b08980a9330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857a56adb973d294e1cf85acca8efbad"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a857a56adb973d294e1cf85acca8efbad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a857a56adb973d294e1cf85acca8efbad">start_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:a857a56adb973d294e1cf85acca8efbad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722ecea4d64dc7853d3825f24f316b47"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a722ecea4d64dc7853d3825f24f316b47"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a722ecea4d64dc7853d3825f24f316b47">start_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a722ecea4d64dc7853d3825f24f316b47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad946c82d0e31a99d76d83230b33ff68f"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE &gt; </td></tr>
<tr class="memitem:ad946c82d0e31a99d76d83230b33ff68f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#ad946c82d0e31a99d76d83230b33ff68f">reentrant_push</a> (ELEMENT_COMPLETE_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:ad946c82d0e31a99d76d83230b33ff68f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a99a0cef94c1cde53cf68ce8c11bbc74f">reentrant_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a99a0cef94c1cde53cf68ce8c11bbc74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3c73b2740ce46477422fb90d18208"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a43e3c73b2740ce46477422fb90d18208"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a43e3c73b2740ce46477422fb90d18208">start_reentrant_push</a> (ELEMENT_TYPE &amp;&amp;i_source)</td></tr>
<tr class="separator:a43e3c73b2740ce46477422fb90d18208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aa035e6311be7c63c72334427572193"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a6aa035e6311be7c63c72334427572193"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a6aa035e6311be7c63c72334427572193">start_reentrant_emplace</a> (CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params)</td></tr>
<tr class="separator:a6aa035e6311be7c63c72334427572193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc627613adc95fa46a26b25ef1209277"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE &gt; </td></tr>
<tr class="memitem:afc627613adc95fa46a26b25ef1209277"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#afc627613adc95fa46a26b25ef1209277">try_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, ELEMENT_COMPLETE_TYPE &amp;&amp;i_source) noexcept(noexcept(m_queue                                                                                                                                                               .try_push(                                                                                                                                                                       i_progress_guarantee,                                                                                                                                                                       std::forward&lt; ELEMENT_COMPLETE_TYPE &gt;(i_source))))</td></tr>
<tr class="separator:afc627613adc95fa46a26b25ef1209277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6daf4e2562d1ee55f65bddb5f1d277ae"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a6daf4e2562d1ee55f65bddb5f1d277ae"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a6daf4e2562d1ee55f65bddb5f1d277ae">try_emplace</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params) noexcept(                                       noexcept(m_queue.template try_emplace&lt; ELEMENT_COMPLETE_TYPE &gt;(                                               i_progress_guarantee, std::forward&lt; CONSTRUCTION_PARAMS &gt;(i_construction_params)...)))</td></tr>
<tr class="separator:a6daf4e2562d1ee55f65bddb5f1d277ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a8b6f8a0f394b23785d5f52fe80563"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a00a8b6f8a0f394b23785d5f52fe80563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a00a8b6f8a0f394b23785d5f52fe80563">try_start_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, ELEMENT_TYPE &amp;&amp;i_source) noexcept(noexcept(m_queue                                                                                                                                                                                                                       .try_start_push(                                                                                                                                                                                                                               i_progress_guarantee,                                                                                                                                                                                                                               std::forward&lt; ELEMENT_TYPE &gt;(i_source))))</td></tr>
<tr class="separator:a00a8b6f8a0f394b23785d5f52fe80563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f54f08e2e3608cb8485eb4664d14dc3"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a0f54f08e2e3608cb8485eb4664d14dc3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a0f54f08e2e3608cb8485eb4664d14dc3">try_start_emplace</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params) noexcept(noexcept(m_queue                                                                                                                                                                                                                                                                                                                   .template try_start_emplace&lt;                                                                                                                                                                                                                                                                                                                              ELEMENT_TYPE &gt;(                                                                                                                                                                                                                                                                                                                           i_progress_guarantee,                                                                                                                                                                                                                                                                                                                           std::forward&lt;                                                                                                                                                                                                                                                                                                                                      ELEMENT_TYPE &gt;(                                                                                                                                                                                                                                                                                                                                   i_construction_params)...)))</td></tr>
<tr class="separator:a0f54f08e2e3608cb8485eb4664d14dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4cac98ee23b919b4d349f1a05a9910"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE &gt; </td></tr>
<tr class="memitem:aff4cac98ee23b919b4d349f1a05a9910"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#aff4cac98ee23b919b4d349f1a05a9910">try_reentrant_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, ELEMENT_COMPLETE_TYPE &amp;&amp;i_source) noexcept(noexcept(m_queue                                                                                                                                                               .try_reentrant_push(                                                                                                                                                                       i_progress_guarantee,                                                                                                                                                                       std::forward&lt; ELEMENT_COMPLETE_TYPE &gt;(i_source))))</td></tr>
<tr class="separator:aff4cac98ee23b919b4d349f1a05a9910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579ba6226f1db029fc0c630d1210ffbf"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_COMPLETE_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a579ba6226f1db029fc0c630d1210ffbf"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a579ba6226f1db029fc0c630d1210ffbf">try_reentrant_emplace</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params) noexcept(noexcept(m_queue                                                                                                                                                                                                                                                                                                                   .template try_reentrant_emplace&lt;                                                                                                                                                                                                                                                                                                                              ELEMENT_COMPLETE_TYPE &gt;(                                                                                                                                                                                                                                                                                                                           i_progress_guarantee,                                                                                                                                                                                                                                                                                                                           std::forward&lt;                                                                                                                                                                                                                                                                                                                                      CONSTRUCTION_PARAMS &gt;(                                                                                                                                                                                                                                                                                                                                   i_construction_params)...)))</td></tr>
<tr class="separator:a579ba6226f1db029fc0c630d1210ffbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cff63f379da1ee525b89ec195e44cf"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE &gt; </td></tr>
<tr class="memitem:a23cff63f379da1ee525b89ec195e44cf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt; typename std::decay&lt; ELEMENT_TYPE &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a23cff63f379da1ee525b89ec195e44cf">try_start_reentrant_push</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, ELEMENT_TYPE &amp;&amp;i_source) noexcept(noexcept(m_queue                                                                                                                                                                                                                       .try_start_reentrant_push(                                                                                                                                                                                                                               i_progress_guarantee,                                                                                                                                                                                                                               std::forward&lt; ELEMENT_TYPE &gt;(i_source))))</td></tr>
<tr class="separator:a23cff63f379da1ee525b89ec195e44cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cce662a32b916aa715f9e6c065d1de"><td class="memTemplParams" colspan="2">template&lt;typename ELEMENT_TYPE , typename... CONSTRUCTION_PARAMS&gt; </td></tr>
<tr class="memitem:a88cce662a32b916aa715f9e6c065d1de"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt; ELEMENT_TYPE &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a88cce662a32b916aa715f9e6c065d1de">try_start_reentrant_emplace</a> (<a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a> i_progress_guarantee, CONSTRUCTION_PARAMS &amp;&amp;...i_construction_params) noexcept(noexcept(m_queue                                                                                                                                                                                                                                                                                                                   .template try_start_reentrant_emplace&lt;                                                                                                                                                                                                                                                                                                                              ELEMENT_TYPE &gt;(                                                                                                                                                                                                                                                                                                                           i_progress_guarantee,                                                                                                                                                                                                                                                                                                                           std::forward&lt;                                                                                                                                                                                                                                                                                                                                      ELEMENT_TYPE &gt;(                                                                                                                                                                                                                                                                                                                                   i_construction_params)...)))</td></tr>
<tr class="separator:a88cce662a32b916aa715f9e6c065d1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf38e05e9b796684eb5b1667f8a5b6ee"><td class="memItemLeft" align="right" valign="top">std::conditional&lt; std::is_void&lt; RET_VAL &gt;::value, bool, <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">density::optional</a>&lt; RET_VAL &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#aaf38e05e9b796684eb5b1667f8a5b6ee">try_consume</a> (PARAMS...i_params)</td></tr>
<tr class="separator:aaf38e05e9b796684eb5b1667f8a5b6ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299c0d82181b94d65f5ad24154001d29"><td class="memItemLeft" align="right" valign="top">std::conditional&lt; std::is_void&lt; RET_VAL &gt;::value, bool, <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">optional</a>&lt; RET_VAL &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a299c0d82181b94d65f5ad24154001d29">try_consume</a> (<a class="el" href="classdensity_1_1sp__function__queue.html#a5f4be9414604d34f18d1ac4c57f7cccc">consume_operation</a> &amp;i_consume, PARAMS...i_params)</td></tr>
<tr class="separator:a299c0d82181b94d65f5ad24154001d29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91078390c44d55b11d98bd5d267d5201"><td class="memItemLeft" align="right" valign="top">std::conditional&lt; std::is_void&lt; RET_VAL &gt;::value, bool, <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">density::optional</a>&lt; RET_VAL &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a91078390c44d55b11d98bd5d267d5201">try_reentrant_consume</a> (PARAMS...i_params)</td></tr>
<tr class="separator:a91078390c44d55b11d98bd5d267d5201"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a14990337d472560c461aa940debd5f"><td class="memItemLeft" align="right" valign="top">std::conditional&lt; std::is_void&lt; RET_VAL &gt;::value, bool, <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">optional</a>&lt; RET_VAL &gt; &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a5a14990337d472560c461aa940debd5f">try_reentrant_consume</a> (<a class="el" href="classdensity_1_1sp__function__queue.html#a9808b16fc781b09c2b6389fcbad45ee5">reentrant_consume_operation</a> &amp;i_consume, PARAMS...i_params)</td></tr>
<tr class="separator:a5a14990337d472560c461aa940debd5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7fecf53c8144b528ed8f4be520a3fd4"><td class="memTemplParams" colspan="2">template&lt;function_type_erasure ERASURE_ = ERASURE, typename std::enable_if&lt; ERASURE_!=function_manual_clear &gt;::type *  = nullptr&gt; </td></tr>
<tr class="memitem:ad7fecf53c8144b528ed8f4be520a3fd4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#ad7fecf53c8144b528ed8f4be520a3fd4">clear</a> () noexcept</td></tr>
<tr class="separator:ad7fecf53c8144b528ed8f4be520a3fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3a9cd8ecff6bf0b9cb102b4a4f4b64"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a3d3a9cd8ecff6bf0b9cb102b4a4f4b64">empty</a> () noexcept</td></tr>
<tr class="separator:a3d3a9cd8ecff6bf0b9cb102b4a4f4b64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a58697d487018a8bde47d4c274c7bd76a"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a58697d487018a8bde47d4c274c7bd76a">concurrent_puts</a> = PROD_CARDINALITY == <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cba88621d57c38a770975b5e262d557c06b">concurrency_multiple</a></td></tr>
<tr class="separator:a58697d487018a8bde47d4c274c7bd76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2bd4f332d922d3024a4bb65f9d17e4"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a2e2bd4f332d922d3024a4bb65f9d17e4">concurrent_consumes</a> = CONSUMER_CARDINALITY == <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cba88621d57c38a770975b5e262d557c06b">concurrency_multiple</a></td></tr>
<tr class="separator:a2e2bd4f332d922d3024a4bb65f9d17e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30744c14b0233cd7f55466ff04151aa9"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a30744c14b0233cd7f55466ff04151aa9">concurrent_put_consumes</a> = true</td></tr>
<tr class="separator:a30744c14b0233cd7f55466ff04151aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7708a88b67261ef454d875047bcfa79d"><td class="memItemLeft" align="right" valign="top">static constexpr bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a7708a88b67261ef454d875047bcfa79d">is_seq_cst</a> = true</td></tr>
<tr class="separator:a7708a88b67261ef454d875047bcfa79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a288adeb13b1cf249dea53a54fee0e6c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1sp__function__queue.html#a288adeb13b1cf249dea53a54fee0e6c5">swap</a> (<a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> &amp;i_first, <a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> &amp;i_second) noexcept</td></tr>
<tr class="separator:a288adeb13b1cf249dea53a54fee0e6c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename CALLABLE, typename ALLOCATOR_TYPE = default_allocator, function_type_erasure ERASURE = function_standard_erasure, concurrency_cardinality PROD_CARDINALITY = concurrency_multiple, concurrency_cardinality CONSUMER_CARDINALITY = concurrency_multiple, typename BUSY_WAIT_FUNC = default_busy_wait&gt;<br />
class density::sp_function_queue&lt; CALLABLE, ALLOCATOR_TYPE, ERASURE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt;</h3>

<p>Heterogeneous FIFO pseudo-container specialized to hold callable objects. <a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> is an adaptor for <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a>.</p>
<p><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> is a concurrent version of <a class="el" href="classdensity_1_1function__queue.html">function_queue</a> that uses a mix of lock free algorithms and spin locking. This class is very similar to <a class="el" href="classdensity_1_1lf__function__queue.html">lf_function_queue</a>, with the difference that if multiple producers are supported, they use a spin-locking mutex to synchronize the write to the tail pointer.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">CALLABLE</td><td>Signature required to the callable objects. Must be in the form RET_VAL (PARAMS...) </td></tr>
    <tr><td class="paramname">ALLOCATOR_TYPE</td><td>Allocator type to be used. This type must satisfy the requirements of both <a class="el" href="UntypedAllocator_requirements.html">UntypedAllocator</a> and <a class="el" href="PagedAllocator_requirements.html">PagedAllocator</a>. The default is <a class="el" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">density::default_allocator</a>. </td></tr>
    <tr><td class="paramname">ERASURE</td><td>Type erasure to use the callable objects. Must be a member of <a class="el" href="namespacedensity.html#a80100b808e35e98df3ffe74cc2293309">density::function_type_erasure</a>. </td></tr>
    <tr><td class="paramname">PROD_CARDINALITY</td><td>specifies whether multiple threads can do put transactions concurrently. Must be a member of <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cb">density::concurrency_cardinality</a>. </td></tr>
    <tr><td class="paramname">CONSUMER_CARDINALITY</td><td>specifies whether multiple threads can do consume operations concurrently. Must be a member of <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cb">density::concurrency_cardinality</a>. </td></tr>
    <tr><td class="paramname">BUSY_WAIT_FUNC</td><td>callable object to be invoked (with an empty parameter list) in the body of the spin lock. The default is <a class="el" href="classdensity_1_1default__busy__wait.html">density::default_busy_wait</a>, that calls std::this_thread::yield.</td></tr>
  </table>
  </dd>
</dl>
<p>If ERASURE == function_manual_clear, <a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> is not able to destroy the callable objects without invoking them. This produces a performance benefit, but:</p><ul>
<li>The function <a class="el" href="classdensity_1_1sp__function__queue.html#ad7fecf53c8144b528ed8f4be520a3fd4">sp_function_queue::clear</a> can't be used (calling it causes undefined behavior)</li>
<li>When the destructor of <a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> is called, the queue must be already empty</li>
</ul>
<p><br />
 <b>Thread safeness</b>: A thread doing put operations and another thread doing consumes don't need to be synchronized. If PROD_CARDINALITY is concurrency_multiple, multiple threads are allowed to put without any synchronization. If CONSUMER_CARDINALITY is concurrency_multiple, multiple threads are allowed to consume without any synchronization. <br />
 <b>Exception safeness</b>: Any function of <a class="el" href="classdensity_1_1sp__heter__queue.html">sp_heter_queue</a> is noexcept or provides the strong exception guarantee.</p>
<p>This class template provides all the put functions provided by <a class="el" href="classdensity_1_1function__queue.html">function_queue</a>, and furthermore it adds the try_ variants, that:</p><ul>
<li>Don't throw in case of failure allocating memory. Anyway they pass through any exception thrown by the constructor of the element and the constructor of the runtime type.</li>
<li>Allow to specify a progress guarantee to be respected by the overall operation. For example, if the lock-free guarantee is requested, but it requires a memory operation that the allocator is not able to complete in lock-freedom, the put fails. In the current implementation, wait-free put operation may fail even in isolation, because page pinning is lock-free but not wait-free. </li>
</ul>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a0c5a5dbd9e7421267b61f14bbe16e203"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a> =  typename UnderlyingQueue::template <a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt;ELEMENT_COMPLETE_TYPE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias to <a class="el" href="classdensity_1_1sp__heter__queue_1_1put__transaction.html">sp_heter_queue::put_transaction</a>. </p>

</div>
</div>
<a class="anchor" id="a388fe9f5a77185b531f9133276131bf1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a> =  typename UnderlyingQueue::template <a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt;ELEMENT_COMPLETE_TYPE&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias to <a class="el" href="classdensity_1_1sp__heter__queue_1_1reentrant__put__transaction.html">sp_heter_queue::reentrant_put_transaction</a>. </p>

</div>
</div>
<a class="anchor" id="a5f4be9414604d34f18d1ac4c57f7cccc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdensity_1_1sp__function__queue.html#a5f4be9414604d34f18d1ac4c57f7cccc">consume_operation</a> =  typename UnderlyingQueue::consume_operation</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias to <a class="el" href="classdensity_1_1lf__heter__queue_1_1consume__operation.html">lf_heter_queue::consume_operation</a>. </p>

</div>
</div>
<a class="anchor" id="a9808b16fc781b09c2b6389fcbad45ee5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdensity_1_1sp__function__queue.html#a9808b16fc781b09c2b6389fcbad45ee5">reentrant_consume_operation</a> =  typename UnderlyingQueue::reentrant_consume_operation</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias to <a class="el" href="classdensity_1_1lf__heter__queue_1_1reentrant__consume__operation.html">lf_heter_queue::reentrant_consume_operation</a>. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ad8d4d19008b24c9cb9755d03c977a55a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  int(<span class="keywordtype">float</span>, <span class="keywordtype">double</span>),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                assert(queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad2c5104bf51635dc3ef1ea90fd679cc5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a>&lt; CALLABLE, ALLOCATOR_TYPE, ERASURE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  int(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                queue.push([] { <span class="keywordflow">return</span> 6; });</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> queue_1(std::move(queue));</div><div class="line">                assert(queue.empty());</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> result = queue_1.try_consume();</div><div class="line">                assert(result &amp;&amp; *result == 6);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a528c4f64ed579d46ff11156baaadc279"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ae853919c01aec9409d9d133f4f25d8c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a>&lt; CALLABLE, ALLOCATOR_TYPE, ERASURE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  int(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue, queue_1;</div><div class="line">                queue.push([] { <span class="keywordflow">return</span> 6; });</div><div class="line"></div><div class="line">                queue_1 = std::move(queue);</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> result = queue_1.try_consume();</div><div class="line">                assert(result &amp;&amp; *result == 6);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ab16cc74a3c5e9d1f9bf798029df5274a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_COMPLETE_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue a callable object.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#ae79645ce0f8c0616bbfda669fa6fbadf">sp_heter_queue::push</a> for a detailed description.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                queue.push([] { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello&quot;</span>; });</div><div class="line">                queue.push([] { std::cout &lt;&lt; <span class="stringliteral">&quot; world&quot;</span>; });</div><div class="line">                queue.push([] { std::cout &lt;&lt; <span class="stringliteral">&quot;!!!&quot;</span>; });</div><div class="line">                queue.push([] { std::cout &lt;&lt; std::endl; });</div><div class="line">                <span class="keywordflow">while</span> (queue.try_consume())</div><div class="line">                    ;</div></div><!-- fragment --><div class="fragment"><div class="line">                <span class="keywordtype">double</span> last_val = 1.;</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> func = [&amp;last_val] { <span class="keywordflow">return</span> last_val /= 2.; };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  double(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++)</div><div class="line">                    queue.push(func);</div><div class="line"></div><div class="line">                <span class="keywordflow">while</span> (<span class="keyword">auto</span> <span class="keyword">const</span> return_value = queue.try_consume())</div><div class="line">                    std::cout &lt;&lt; *return_value &lt;&lt; std::endl;</div></div><!-- fragment --><div class="fragment"><div class="line"><span class="preprocessor">#if !defined(_MSC_VER) || !defined(_M_X64) </span><span class="comment">/* the size of a type must always be a multiple of</span></div><div class="line"><span class="comment">        the alignment, but in the microsoft&#39;s compiler, on 64-bit targets, pointers to data</span></div><div class="line"><span class="comment">        member are 4 bytes big, but are aligned to 8 bytes.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">        Test code:</span></div><div class="line"><span class="comment">            using T = int Struct::*;</span></div><div class="line"><span class="comment">            std::cout &lt;&lt; sizeof(T) &lt;&lt; std::endl;</span></div><div class="line"><span class="comment">            std::cout &lt;&lt; alignof(T) &lt;&lt; std::endl;</span></div><div class="line"><span class="comment">        */</span><span class="preprocessor"></span></div><div class="line"></div><div class="line">                <span class="keyword">struct </span>Struct</div><div class="line">                {</div><div class="line">                    <span class="keywordtype">int</span> func_1() { <span class="keywordflow">return</span> 1; }</div><div class="line">                    <span class="keywordtype">int</span> func_2() { <span class="keywordflow">return</span> 2; }</div><div class="line">                    <span class="keywordtype">int</span> var_1 = 3;</div><div class="line">                    <span class="keywordtype">int</span> var_2 = 4;</div><div class="line">                };</div><div class="line"></div><div class="line">                sp_function_queue&lt;int(Struct *)&gt; queue;</div><div class="line">                queue.push(&amp;Struct::func_1);</div><div class="line">                queue.push(&amp;Struct::func_2);</div><div class="line">                queue.push(&amp;Struct::var_1);</div><div class="line">                queue.push(&amp;Struct::var_2);</div><div class="line"></div><div class="line">                Struct struct_instance;</div><div class="line"></div><div class="line">                <span class="keywordtype">int</span> sum = 0;</div><div class="line">                <span class="keywordflow">while</span> (<span class="keyword">auto</span> <span class="keyword">const</span> return_value = queue.try_consume(&amp;struct_instance))</div><div class="line">                    sum += *return_value;</div><div class="line">                assert(sum == 10);</div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a49d0820906b9bd4c1b5a1b08980a9330"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue a callable object of type <code>ELEMENT_COMPLETE_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 <em>Note</em>: the template argument <code>ELEMENT_COMPLETE_TYPE</code> can't be deduced from the parameters so it must explicitly specified.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a49d0820906b9bd4c1b5a1b08980a9330">sp_heter_queue::emplace</a> for a detailed description.</p>
<div class="fragment"><div class="line">                <span class="comment">/* This local struct is unmovable and uncopyable, so emplace is the only</span></div><div class="line"><span class="comment">                    option to add it to the queue. Note that operator () returns an int,</span></div><div class="line"><span class="comment">                    but we add it to a void() function queue. This is ok, as we are just</span></div><div class="line"><span class="comment">                    discarding the return value. */</span></div><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keywordtype">int</span> <span class="keyword">const</span> m_value;</div><div class="line"></div><div class="line">                    Func(<span class="keywordtype">int</span> i_value) : m_value(i_value) {}</div><div class="line"></div><div class="line">                    Func(<span class="keyword">const</span> Func &amp;) = <span class="keyword">delete</span>;</div><div class="line">                    Func &amp; <a class="code" href="classdensity_1_1sp__function__queue.html#ae853919c01aec9409d9d133f4f25d8c8">operator=</a>(<span class="keyword">const</span> Func &amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">                    <span class="keywordtype">int</span> operator()()<span class="keyword"> const</span></div><div class="line"><span class="keyword">                    </span>{</div><div class="line">                        std::cout &lt;&lt; m_value &lt;&lt; std::endl;</div><div class="line">                        <span class="keywordflow">return</span> m_value;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                queue.template emplace&lt;Func&gt;(7);</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> <span class="keyword">const</span> invoked = queue.try_consume();</div><div class="line">                assert(invoked);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a857a56adb973d294e1cf85acca8efbad"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; start_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a857a56adb973d294e1cf85acca8efbad">sp_heter_queue::start_push</a> for a detailed description.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_1;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_2;</div><div class="line"></div><div class="line">                    <span class="keywordtype">void</span> operator()()</div><div class="line">                    {</div><div class="line">                        std::cout &lt;&lt; m_string_1 &lt;&lt; std::endl;</div><div class="line">                        std::cout &lt;&lt; m_string_2 &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                     queue;</div><div class="line">                <span class="keyword">auto</span> transaction = queue.start_push(Func{});</div><div class="line"></div><div class="line">                <span class="comment">// in case of exception here, since the transaction is not committed, it is discarded with no observable effects</span></div><div class="line">                transaction.element().m_string_1 = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world&quot;</span>);</div><div class="line">                transaction.element().m_string_2 =</div><div class="line">                  transaction.raw_allocate_copy(<span class="stringliteral">&quot;\t(I&#39;m so happy)!!&quot;</span>);</div><div class="line"></div><div class="line">                transaction.commit();</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> <span class="keyword">const</span> invoked = queue.try_consume();</div><div class="line">                assert(invoked);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a722ecea4d64dc7853d3825f24f316b47"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt;ELEMENT_TYPE&gt; start_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a722ecea4d64dc7853d3825f24f316b47">sp_heter_queue::start_emplace</a> for a detailed description.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_1;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_2;</div><div class="line"></div><div class="line">                    <span class="keywordtype">void</span> operator()()</div><div class="line">                    {</div><div class="line">                        std::cout &lt;&lt; m_string_1 &lt;&lt; std::endl;</div><div class="line">                        std::cout &lt;&lt; m_string_2 &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                     queue;</div><div class="line">                <span class="keyword">auto</span> transaction = queue.template start_emplace&lt;Func&gt;();</div><div class="line"></div><div class="line">                <span class="comment">// in case of exception here, since the transaction is not committed, it is discarded with no observable effects</span></div><div class="line">                transaction.element().m_string_1 = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world&quot;</span>);</div><div class="line">                transaction.element().m_string_2 =</div><div class="line">                  transaction.raw_allocate_copy(<span class="stringliteral">&quot;\t(I&#39;m so happy)!!&quot;</span>);</div><div class="line"></div><div class="line">                transaction.commit();</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> <span class="keyword">const</span> invoked = queue.try_consume();</div><div class="line">                assert(invoked);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad946c82d0e31a99d76d83230b33ff68f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_COMPLETE_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue a callable object.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#abd4493f55adeab87efb382c118066a2e">sp_heter_queue::reentrant_push</a> for a detailed description.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                queue.reentrant_push([] { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello&quot;</span>; });</div><div class="line">                queue.reentrant_push([] { std::cout &lt;&lt; <span class="stringliteral">&quot; world&quot;</span>; });</div><div class="line">                queue.reentrant_push([] { std::cout &lt;&lt; <span class="stringliteral">&quot;!!!&quot;</span>; });</div><div class="line">                queue.reentrant_push([] { std::cout &lt;&lt; std::endl; });</div><div class="line">                <span class="keywordflow">while</span> (queue.try_reentrant_consume())</div><div class="line">                    ;</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a99a0cef94c1cde53cf68ce8c11bbc74f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adds at the end of the queue a callable object of type <code>ELEMENT_COMPLETE_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 <em>Note</em>: the template argument <code>ELEMENT_COMPLETE_TYPE</code> can't be deduced from the parameters so it must explicitly specified.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a99a0cef94c1cde53cf68ce8c11bbc74f">sp_heter_queue::reentrant_emplace</a> for a detailed description.</p>
<div class="fragment"><div class="line">                <span class="comment">/* This local struct is unmovable and uncopyable, so emplace is the only</span></div><div class="line"><span class="comment">                    option to add it to the queue. Note that operator () returns an int,</span></div><div class="line"><span class="comment">                    but we add it to a void() function queue. This is ok, as we are just</span></div><div class="line"><span class="comment">                    discarding the return value. */</span></div><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keywordtype">int</span> <span class="keyword">const</span> m_value;</div><div class="line"></div><div class="line">                    Func(<span class="keywordtype">int</span> i_value) : m_value(i_value) {}</div><div class="line"></div><div class="line">                    Func(<span class="keyword">const</span> Func &amp;) = <span class="keyword">delete</span>;</div><div class="line">                    Func &amp; <a class="code" href="classdensity_1_1sp__function__queue.html#ae853919c01aec9409d9d133f4f25d8c8">operator=</a>(<span class="keyword">const</span> Func &amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">                    <span class="keywordtype">int</span> operator()()<span class="keyword"> const</span></div><div class="line"><span class="keyword">                    </span>{</div><div class="line">                        std::cout &lt;&lt; m_value &lt;&lt; std::endl;</div><div class="line">                        <span class="keywordflow">return</span> m_value;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                queue.template reentrant_emplace&lt;Func&gt;(7);</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> <span class="keyword">const</span> invoked = queue.try_reentrant_consume();</div><div class="line">                assert(invoked);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a43e3c73b2740ce46477422fb90d18208"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; start_reentrant_push </td>
          <td>(</td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a43e3c73b2740ce46477422fb90d18208">sp_heter_queue::start_reentrant_push</a> for a detailed description.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_1;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_2;</div><div class="line"></div><div class="line">                    <span class="keywordtype">void</span> operator()()</div><div class="line">                    {</div><div class="line">                        std::cout &lt;&lt; m_string_1 &lt;&lt; std::endl;</div><div class="line">                        std::cout &lt;&lt; m_string_2 &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> transaction = queue.start_reentrant_push(Func{});</div><div class="line"></div><div class="line">                <span class="comment">// in case of exception here, since the transaction is not committed, it is discarded with no observable effects</span></div><div class="line">                transaction.element().m_string_1 = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world&quot;</span>);</div><div class="line">                transaction.element().m_string_2 =</div><div class="line">                  transaction.raw_allocate_copy(<span class="stringliteral">&quot;\t(I&#39;m so happy)!!&quot;</span>);</div><div class="line"></div><div class="line">                transaction.commit();</div><div class="line"></div><div class="line">                <span class="comment">// now transaction is empty</span></div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> <span class="keyword">const</span> invoked = queue.try_reentrant_consume();</div><div class="line">                assert(invoked);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6aa035e6311be7c63c72334427572193"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt;ELEMENT_TYPE&gt; start_reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Begins a transaction that appends an element of a type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a6aa035e6311be7c63c72334427572193">sp_heter_queue::start_reentrant_emplace</a> for a detailed description.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_1;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_2;</div><div class="line"></div><div class="line">                    <span class="keywordtype">void</span> operator()()</div><div class="line">                    {</div><div class="line">                        std::cout &lt;&lt; m_string_1 &lt;&lt; std::endl;</div><div class="line">                        std::cout &lt;&lt; m_string_2 &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> transaction = queue.template start_reentrant_emplace&lt;Func&gt;();</div><div class="line"></div><div class="line">                <span class="comment">// in case of exception here, since the transaction is not committed, it is discarded with no observable effects</span></div><div class="line">                transaction.element().m_string_1 = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world&quot;</span>);</div><div class="line">                transaction.element().m_string_2 =</div><div class="line">                  transaction.raw_allocate_copy(<span class="stringliteral">&quot;\t(I&#39;m so happy)!!&quot;</span>);</div><div class="line"></div><div class="line">                transaction.commit();</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> <span class="keyword">const</span> invoked = queue.try_reentrant_consume();</div><div class="line">                assert(invoked);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afc627613adc95fa46a26b25ef1209277"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_COMPLETE_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to add at the end of the queue a callable object respecting a progress guarantee.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a41e25326bc37600b884efb3547d6330e">sp_heter_queue::try_push</a> for a detailed description.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> <span class="keyword">const</span> ok =</div><div class="line">                  queue.try_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a532a69752250bfd675c4e00f07d237e4">progress_lock_free</a>, [] { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello world!&quot;</span>; });</div><div class="line"></div><div class="line">                <span class="keywordflow">while</span> (queue.try_consume())</div><div class="line">                    ;</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6daf4e2562d1ee55f65bddb5f1d277ae"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to add at the end of the queue a callable object of type <code>ELEMENT_COMPLETE_TYPE</code> respecting a progress guarantee, inplace-constructing it from a perfect forwarded parameter pack. <br />
 <em>Note</em>: the template argument <code>ELEMENT_COMPLETE_TYPE</code> can't be deduced from the parameters so it must explicitly specified.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a1924e23bc866c313989e7860fc49a4a1">sp_heter_queue::try_emplace</a> for a detailed description.</p>
<div class="fragment"><div class="line">                <span class="comment">/* This local struct is unmovable and uncopyable, so emplace is the only</span></div><div class="line"><span class="comment">                    option to add it to the queue. Note that operator () returns an int,</span></div><div class="line"><span class="comment">                    but we add it to a void() function queue. This is ok, as we are just</span></div><div class="line"><span class="comment">                    discarding the return value. */</span></div><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keywordtype">int</span> <span class="keyword">const</span> m_value;</div><div class="line"></div><div class="line">                    Func(<span class="keywordtype">int</span> i_value) : m_value(i_value) {}</div><div class="line"></div><div class="line">                    Func(<span class="keyword">const</span> Func &amp;) = <span class="keyword">delete</span>;</div><div class="line">                    Func &amp; <a class="code" href="classdensity_1_1sp__function__queue.html#ae853919c01aec9409d9d133f4f25d8c8">operator=</a>(<span class="keyword">const</span> Func &amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">                    <span class="keywordtype">int</span> operator()()<span class="keyword"> const</span></div><div class="line"><span class="keyword">                    </span>{</div><div class="line">                        std::cout &lt;&lt; m_value &lt;&lt; std::endl;</div><div class="line">                        <span class="keywordflow">return</span> m_value;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                     queue;</div><div class="line">                <span class="keywordtype">bool</span> invoked = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">if</span> (queue.template try_emplace&lt;Func&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a532a69752250bfd675c4e00f07d237e4">progress_lock_free</a>, 7))</div><div class="line">                {</div><div class="line">                    invoked = queue.try_consume();</div><div class="line">                    assert(invoked);</div><div class="line">                }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a00a8b6f8a0f394b23785d5f52fe80563"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; try_start_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction that appends an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a316639ed6c5407de6ec7359372c9dfb6">sp_heter_queue::try_start_push</a> for a detailed description.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_1;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_2;</div><div class="line"></div><div class="line">                    <span class="keywordtype">void</span> operator()()</div><div class="line">                    {</div><div class="line">                        std::cout &lt;&lt; m_string_1 &lt;&lt; std::endl;</div><div class="line">                        std::cout &lt;&lt; m_string_2 &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> invoked = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">if</span> (<span class="keyword">auto</span> transaction = queue.try_start_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a532a69752250bfd675c4e00f07d237e4">progress_lock_free</a>, Func{}))</div><div class="line">                {</div><div class="line">                    <span class="comment">// in case of exception here, since the transaction is not committed, it is discarded with no observable effects</span></div><div class="line">                    transaction.element().m_string_1 = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world&quot;</span>);</div><div class="line">                    transaction.element().m_string_2 =</div><div class="line">                      transaction.raw_allocate_copy(<span class="stringliteral">&quot;\t(I&#39;m so happy)!!&quot;</span>);</div><div class="line"></div><div class="line">                    transaction.commit();</div><div class="line"></div><div class="line">                    invoked = queue.try_consume();</div><div class="line">                    assert(invoked);</div><div class="line">                }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0f54f08e2e3608cb8485eb4664d14dc3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html#a0c5a5dbd9e7421267b61f14bbe16e203">put_transaction</a>&lt;ELEMENT_TYPE&gt; try_start_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction appends an element of a type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a5d796cc862cda3ee834bd8cf0af62436">sp_heter_queue::try_start_emplace</a> for a detailed description.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_1;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_2;</div><div class="line"></div><div class="line">                    <span class="keywordtype">void</span> operator()()</div><div class="line">                    {</div><div class="line">                        std::cout &lt;&lt; m_string_1 &lt;&lt; std::endl;</div><div class="line">                        std::cout &lt;&lt; m_string_2 &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                     queue;</div><div class="line">                <span class="keywordtype">bool</span> invoked = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">if</span> (<span class="keyword">auto</span> transaction = queue.template try_start_emplace&lt;Func&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a532a69752250bfd675c4e00f07d237e4">progress_lock_free</a>))</div><div class="line">                {</div><div class="line">                    <span class="comment">// in case of exception here, since the transaction is not committed, it is discarded with no observable effects</span></div><div class="line">                    transaction.element().m_string_1 = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world&quot;</span>);</div><div class="line">                    transaction.element().m_string_2 =</div><div class="line">                      transaction.raw_allocate_copy(<span class="stringliteral">&quot;\t(I&#39;m so happy)!!&quot;</span>);</div><div class="line"></div><div class="line">                    transaction.commit();</div><div class="line"></div><div class="line">                    invoked = queue.try_consume();</div><div class="line">                    assert(invoked);</div><div class="line">                }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aff4cac98ee23b919b4d349f1a05a9910"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_COMPLETE_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to add at the end of the queue a callable object.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a24c559a6c16f890cb0116f2b9d4a46d9">sp_heter_queue::try_reentrant_push</a> for a detailed description.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                <span class="keywordflow">if</span> (queue.try_reentrant_push(</div><div class="line">                      <a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a532a69752250bfd675c4e00f07d237e4">progress_lock_free</a>, [] { std::cout &lt;&lt; <span class="stringliteral">&quot;Hello world&quot;</span>; }))</div><div class="line">                {</div><div class="line">                    <span class="keywordflow">while</span> (queue.try_reentrant_consume())</div><div class="line">                        ;</div><div class="line">                }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a579ba6226f1db029fc0c630d1210ffbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool try_reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to add at the end of the queue a callable object of type <code>ELEMENT_COMPLETE_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack. <br />
 <em>Note</em>: the template argument <code>ELEMENT_COMPLETE_TYPE</code> can't be deduced from the parameters so it must explicitly specified.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#ab259c75504d4a522bb29dcbded9c6f93">sp_heter_queue::try_reentrant_emplace</a> for a detailed description.</p>
<div class="fragment"><div class="line">                <span class="comment">/* This local struct is unmovable and uncopyable, so emplace is the only</span></div><div class="line"><span class="comment">                    option to add it to the queue. Note that operator () returns an int,</span></div><div class="line"><span class="comment">                    but we add it to a void() function queue. This is ok, as we are just</span></div><div class="line"><span class="comment">                    discarding the return value. */</span></div><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keywordtype">int</span> <span class="keyword">const</span> m_value;</div><div class="line"></div><div class="line">                    Func(<span class="keywordtype">int</span> i_value) : m_value(i_value) {}</div><div class="line"></div><div class="line">                    Func(<span class="keyword">const</span> Func &amp;) = <span class="keyword">delete</span>;</div><div class="line">                    Func &amp; <a class="code" href="classdensity_1_1sp__function__queue.html#ae853919c01aec9409d9d133f4f25d8c8">operator=</a>(<span class="keyword">const</span> Func &amp;) = <span class="keyword">delete</span>;</div><div class="line"></div><div class="line">                    <span class="keywordtype">int</span> operator()()<span class="keyword"> const</span></div><div class="line"><span class="keyword">                    </span>{</div><div class="line">                        std::cout &lt;&lt; m_value &lt;&lt; std::endl;</div><div class="line">                        <span class="keywordflow">return</span> m_value;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> invoked = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">if</span> (queue.template try_reentrant_emplace&lt;Func&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a532a69752250bfd675c4e00f07d237e4">progress_lock_free</a>, 7))</div><div class="line">                {</div><div class="line">                    invoked = queue.try_reentrant_consume();</div><div class="line">                    assert(invoked);</div><div class="line">                }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a23cff63f379da1ee525b89ec195e44cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt;typename std::decay&lt;ELEMENT_TYPE&gt;::type&gt; try_start_reentrant_push </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ELEMENT_TYPE &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction appends an element of type <code>ELEMENT_TYPE</code>, copy-constructing or move-constructing it from the source.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a2abbe21452193beefc0c03f68c8f9ee4">sp_heter_queue::try_start_reentrant_push</a> for a detailed description.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_1;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_2;</div><div class="line"></div><div class="line">                    <span class="keywordtype">void</span> operator()()</div><div class="line">                    {</div><div class="line">                        std::cout &lt;&lt; m_string_1 &lt;&lt; std::endl;</div><div class="line">                        std::cout &lt;&lt; m_string_2 &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> invoked = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">if</span> (<span class="keyword">auto</span> transaction = queue.try_start_reentrant_push(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a532a69752250bfd675c4e00f07d237e4">progress_lock_free</a>, Func{}))</div><div class="line">                {</div><div class="line">                    <span class="comment">// in case of exception here, since the transaction is not committed, it is discarded with no observable effects</span></div><div class="line">                    transaction.element().m_string_1 = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world&quot;</span>);</div><div class="line">                    transaction.element().m_string_2 =</div><div class="line">                      transaction.raw_allocate_copy(<span class="stringliteral">&quot;\t(I&#39;m so happy)!!&quot;</span>);</div><div class="line"></div><div class="line">                    transaction.commit();</div><div class="line"></div><div class="line">                    <span class="comment">// now transaction is empty</span></div><div class="line"></div><div class="line">                    invoked = queue.try_reentrant_consume();</div><div class="line">                    assert(invoked);</div><div class="line">                }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a88cce662a32b916aa715f9e6c065d1de"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1sp__function__queue.html#a388fe9f5a77185b531f9133276131bf1">reentrant_put_transaction</a>&lt;ELEMENT_TYPE&gt; try_start_reentrant_emplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9">progress_guarantee</a>&#160;</td>
          <td class="paramname"><em>i_progress_guarantee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CONSTRUCTION_PARAMS &amp;&amp;...&#160;</td>
          <td class="paramname"><em>i_construction_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to begin a transaction appends an element of a type <code>ELEMENT_TYPE</code>, inplace-constructing it from a perfect forwarded parameter pack.</p>
<p>See <a class="el" href="classdensity_1_1sp__heter__queue.html#a21284a93fb4dce1fe18333d7dd962c04">sp_heter_queue::try_start_reentrant_emplace</a> for a detailed description.</p>
<p><b>Examples</b> </p><div class="fragment"><div class="line">                <span class="keyword">struct </span>Func</div><div class="line">                {</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_1;</div><div class="line">                    <span class="keyword">const</span> <span class="keywordtype">char</span> * m_string_2;</div><div class="line"></div><div class="line">                    <span class="keywordtype">void</span> operator()()</div><div class="line">                    {</div><div class="line">                        std::cout &lt;&lt; m_string_1 &lt;&lt; std::endl;</div><div class="line">                        std::cout &lt;&lt; m_string_2 &lt;&lt; std::endl;</div><div class="line">                    }</div><div class="line">                };</div><div class="line"></div><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keywordtype">bool</span> invoked = <span class="keyword">false</span>;</div><div class="line">                <span class="keywordflow">if</span> (</div><div class="line">                  <span class="keyword">auto</span> transaction =</div><div class="line">                    queue.template try_start_reentrant_emplace&lt;Func&gt;(<a class="code" href="namespacedensity.html#a457b018b32da6a356fb3a90d75526ca9a532a69752250bfd675c4e00f07d237e4">progress_lock_free</a>))</div><div class="line">                {</div><div class="line">                    <span class="comment">// in case of exception here, since the transaction is not committed, it is discarded with no observable effects</span></div><div class="line">                    transaction.element().m_string_1 = transaction.raw_allocate_copy(<span class="stringliteral">&quot;Hello world&quot;</span>);</div><div class="line">                    transaction.element().m_string_2 =</div><div class="line">                      transaction.raw_allocate_copy(<span class="stringliteral">&quot;\t(I&#39;m so happy)!!&quot;</span>);</div><div class="line"></div><div class="line">                    transaction.commit();</div><div class="line"></div><div class="line">                    invoked = queue.try_reentrant_consume();</div><div class="line">                    assert(invoked);</div><div class="line">                }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaf38e05e9b796684eb5b1667f8a5b6ee"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional&lt;std::is_void&lt;RET_VAL&gt;::value, bool, <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">density::optional</a>&lt;RET_VAL&gt; &gt;:: type try_consume </td>
          <td>(</td>
          <td class="paramtype">PARAMS...&#160;</td>
          <td class="paramname"><em>i_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the queue is not empty, invokes the first function object of the queue and then deletes it from the queue. Otherwise no operation is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_params...</td><td>parameters to be forwarded to the function object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If RET_VAL is void, the return value is a boolean indicating whether a callable object was consumed. Otherwise the return value is an <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">density::optional</a> that contains the value returned by the callable object, or an empty <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">density::optional</a> in case the queue was empty.</dd></dl>
<p>This function is not reentrant: if the callable object accesses in any way this queue, the behavior is undefined. Use <a class="el" href="classdensity_1_1sp__function__queue.html#a91078390c44d55b11d98bd5d267d5201">sp_function_queue::try_reentrant_consume</a> if you are not sure about what the callable object may do.</p>
<p><b>Throws:</b> unspecified <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  int(std::vector&lt;std::string&gt; &amp; vect),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                queue.push([](std::vector&lt;std::string&gt; &amp; vect) {</div><div class="line">                    vect.push_back(<span class="stringliteral">&quot;Hello&quot;</span>);</div><div class="line">                    <span class="keywordflow">return</span> 2;</div><div class="line">                });</div><div class="line"></div><div class="line">                queue.push([](std::vector&lt;std::string&gt; &amp; vect) {</div><div class="line">                    vect.push_back(<span class="stringliteral">&quot; world!&quot;</span>);</div><div class="line">                    <span class="keywordflow">return</span> 3;</div><div class="line">                });</div><div class="line"></div><div class="line">                std::vector&lt;std::string&gt; strings;</div><div class="line"></div><div class="line">                <span class="keywordtype">int</span> sum = 0;</div><div class="line">                <span class="keywordflow">while</span> (<span class="keyword">auto</span> <span class="keyword">const</span> return_value = queue.try_consume(strings))</div><div class="line">                {</div><div class="line">                    sum += *return_value;</div><div class="line">                }</div><div class="line"></div><div class="line">                assert(sum == 5);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp; str : strings)</div><div class="line">                    std::cout &lt;&lt; str;</div><div class="line">                std::cout &lt;&lt; std::endl;</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a299c0d82181b94d65f5ad24154001d29"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional&lt;std::is_void&lt;RET_VAL&gt;::value, bool, <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">optional</a>&lt;RET_VAL&gt; &gt;::type try_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__function__queue.html#a5f4be9414604d34f18d1ac4c57f7cccc">consume_operation</a> &amp;&#160;</td>
          <td class="paramname"><em>i_consume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARAMS...&#160;</td>
          <td class="paramname"><em>i_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the queue is not empty, invokes the first function object of the queue and then deletes it from the queue. Otherwise no operation is performed.</p>
<p>The consume operation is performed using the provided consume_operation object. If the element to consume is in the same page of the last element visited by the provided consume operation, the implementation does not need to pin page. For this reason this overload of try_consume is much faster than the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_consume</td><td>object to use for the consume operation </td></tr>
    <tr><td class="paramname">i_params...</td><td>parameters to be forwarded to the function object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If RET_VAL is void, the return value is a boolean indicating whether a callable object was consumed. Otherwise the return value is an optional that contains the value returned by the callable object, or an empty optional in case the queue was empty.</dd></dl>
<p>This function is not reentrant: if the callable object accesses in any way this queue, the behavior is undefined. Use <a class="el" href="classdensity_1_1sp__function__queue.html#a91078390c44d55b11d98bd5d267d5201">sp_function_queue::try_reentrant_consume</a> if you are not sure about what the callable object may do.</p>
<p><b>Throws:</b> unspecified <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<div class="fragment"><div class="line">                <span class="keyword">using</span> Queue = <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  int(std::vector&lt;std::string&gt; &amp; vect),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;;</div><div class="line">                Queue queue;</div><div class="line"></div><div class="line">                queue.push([](std::vector&lt;std::string&gt; &amp; vect) {</div><div class="line">                    vect.push_back(<span class="stringliteral">&quot;Hello&quot;</span>);</div><div class="line">                    <span class="keywordflow">return</span> 2;</div><div class="line">                });</div><div class="line"></div><div class="line">                queue.push([](std::vector&lt;std::string&gt; &amp; vect) {</div><div class="line">                    vect.push_back(<span class="stringliteral">&quot; world!&quot;</span>);</div><div class="line">                    <span class="keywordflow">return</span> 3;</div><div class="line">                });</div><div class="line"></div><div class="line">                std::vector&lt;std::string&gt; strings;</div><div class="line"></div><div class="line">                <span class="comment">// providing a cached consume_operation gives better performances</span></div><div class="line">                <span class="keyword">typename</span> Queue::consume_operation consume;</div><div class="line"></div><div class="line">                <span class="keywordtype">int</span> sum = 0;</div><div class="line">                <span class="keywordflow">while</span> (<span class="keyword">auto</span> <span class="keyword">const</span> return_value = queue.try_consume(consume, strings))</div><div class="line">                {</div><div class="line">                    sum += *return_value;</div><div class="line">                }</div><div class="line"></div><div class="line">                assert(sum == 5);</div><div class="line"></div><div class="line">                <span class="keywordflow">for</span> (<span class="keyword">auto</span> <span class="keyword">const</span> &amp; str : strings)</div><div class="line">                    std::cout &lt;&lt; str;</div><div class="line">                std::cout &lt;&lt; std::endl;</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a91078390c44d55b11d98bd5d267d5201"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional&lt;std::is_void&lt;RET_VAL&gt;::value, bool, <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">density::optional</a>&lt;RET_VAL&gt; &gt;:: type try_reentrant_consume </td>
          <td>(</td>
          <td class="paramtype">PARAMS...&#160;</td>
          <td class="paramname"><em>i_params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the queue is not empty, invokes the first function object of the queue and then deletes it from the queue. Otherwise no operation is performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_params...</td><td>parameters to be forwarded to the function object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If RET_VAL is void, the return value is a boolean indicating whether a callable object was consumed. Otherwise the return value is an <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">density::optional</a> that contains the value returned by the callable object, or an empty <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">density::optional</a> in case the queue was empty.</dd></dl>
<p>This function is reentrant: the callable object can access in any way this queue.</p>
<p><b>Throws:</b> unspecified <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> func1 = [&amp;queue] {</div><div class="line">                    std::cout &lt;&lt; (queue.empty() ? <span class="stringliteral">&quot;The queue is empty&quot;</span> : <span class="stringliteral">&quot;The queue is not empty&quot;</span>)</div><div class="line">                              &lt;&lt; std::endl;</div><div class="line">                };</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> func2 = [&amp;queue, func1] { queue.push(func1); };</div><div class="line"></div><div class="line">                queue.push(func1);</div><div class="line">                queue.push(func2);</div><div class="line"></div><div class="line">                <span class="comment">/* The callable objects we are going to invoke will access the queue, so we</span></div><div class="line"><span class="comment">                    must use a reentrant consume. Note: during the invoke of the last function</span></div><div class="line"><span class="comment">                    the queue is empty to any observer. */</span></div><div class="line">                <span class="keywordflow">while</span> (queue.try_reentrant_consume())</div><div class="line">                    ;</div><div class="line"></div><div class="line">                <span class="comment">// Output:</span></div><div class="line">                <span class="comment">// The queue is not empty</span></div><div class="line">                <span class="comment">// The queue is empty</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5a14990337d472560c461aa940debd5f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional&lt;std::is_void&lt;RET_VAL&gt;::value, bool, <a class="el" href="namespacedensity.html#ae750738f85fce3a63cae7c9f3f0f2e80">optional</a>&lt;RET_VAL&gt; &gt;::type try_reentrant_consume </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__function__queue.html#a9808b16fc781b09c2b6389fcbad45ee5">reentrant_consume_operation</a> &amp;&#160;</td>
          <td class="paramname"><em>i_consume</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PARAMS...&#160;</td>
          <td class="paramname"><em>i_params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the queue is not empty, invokes the first function object of the queue and then deletes it from the queue. Otherwise no operation is performed.</p>
<p>The consume operation is performed using the provided consume_operation object. If the element to consume is in the same page of the last element visited by the provided consume operation, the implementation does not need to pin page. For this reason this overload of try_reentrant_consume is much faster than the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_consume</td><td>object to use for the consume operation </td></tr>
    <tr><td class="paramname">i_params...</td><td>parameters to be forwarded to the function object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If RET_VAL is void, the return value is a boolean indicating whether a callable object was consumed. Otherwise the return value is an optional that contains the value returned by the callable object, or an empty optional in case the queue was empty.</dd></dl>
<p>This function is reentrant: the callable object can access in any way this queue.</p>
<p><b>Throws:</b> unspecified <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects).</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  void(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> func1 = [&amp;queue] {</div><div class="line">                    std::cout &lt;&lt; (queue.empty() ? <span class="stringliteral">&quot;The queue is empty&quot;</span> : <span class="stringliteral">&quot;The queue is not empty&quot;</span>)</div><div class="line">                              &lt;&lt; std::endl;</div><div class="line">                };</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> func2 = [&amp;queue, func1] { queue.push(func1); };</div><div class="line"></div><div class="line">                queue.push(func1);</div><div class="line">                queue.push(func2);</div><div class="line"></div><div class="line">                <span class="comment">// providing a cached consume_operation gives much better performances</span></div><div class="line">                <span class="keyword">typename</span> decltype(queue)::<a class="code" href="classdensity_1_1sp__function__queue.html#a9808b16fc781b09c2b6389fcbad45ee5">reentrant_consume_operation</a> consume;</div><div class="line"></div><div class="line">                <span class="comment">/* The callable objects we are going to invoke will access the queue, so we</span></div><div class="line"><span class="comment">                    must use a reentrant consume. Note: during the invoke of the last function</span></div><div class="line"><span class="comment">                    the queue is empty to any observer. */</span></div><div class="line">                <span class="keywordflow">while</span> (queue.try_reentrant_consume(consume))</div><div class="line">                    ;</div><div class="line"></div><div class="line">                <span class="comment">// Output:</span></div><div class="line">                <span class="comment">// The queue is not empty</span></div><div class="line">                <span class="comment">// The queue is empty</span></div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ad7fecf53c8144b528ed8f4be520a3fd4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deletes all the callable objects in the queue. This function is disabled at conpile-time if ERASURE is function_manual_clear.</p>
<p><br />
<b> Effects on iterators </b>: all the iterators are invalidated <br />
<b>Throws:</b> nothing <br />
<b>Complexity:</b> linear.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  int(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  <a class="code" href="namespacedensity.html#a80100b808e35e98df3ffe74cc2293309a76acf7643b092fa57f647e10bc2a9cb7">function_standard_erasure</a>,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue;</div><div class="line">                queue.push([] { <span class="keywordflow">return</span> 6; });</div><div class="line">                queue.clear();</div><div class="line">                assert(queue.empty());</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3d3a9cd8ecff6bf0b9cb102b4a4f4b64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns whether this container is empty </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a class="anchor" id="a288adeb13b1cf249dea53a54fee0e6c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a>&lt; CALLABLE, ALLOCATOR_TYPE, ERASURE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classdensity_1_1sp__function__queue.html">sp_function_queue</a>&lt; CALLABLE, ALLOCATOR_TYPE, ERASURE, PROD_CARDINALITY, CONSUMER_CARDINALITY, BUSY_WAIT_FUNC &gt; &amp;&#160;</td>
          <td class="paramname"><em>i_second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swaps two function queues.</p>
<div class="fragment"><div class="line">                <a class="code" href="classdensity_1_1sp__function__queue.html#ad8d4d19008b24c9cb9755d03c977a55a">sp_function_queue</a>&lt;</div><div class="line">                  int(),</div><div class="line">                  <a class="code" href="namespacedensity.html#adeb11d97131a6de72c7b1d4b6c10f342">default_allocator</a>,</div><div class="line">                  ERASURE,</div><div class="line">                  PROD_CARDINALITY,</div><div class="line">                  CONSUMER_CARDINALITY&gt;</div><div class="line">                  queue, queue_1;</div><div class="line">                queue.push([] { <span class="keywordflow">return</span> 6; });</div><div class="line"></div><div class="line">                std::swap(queue, queue_1);</div><div class="line">                assert(queue.empty());</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> result = queue_1.try_consume();</div><div class="line">                assert(result &amp;&amp; *result == 6);</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a58697d487018a8bde47d4c274c7bd76a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_puts = PROD_CARDINALITY == <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cba88621d57c38a770975b5e262d557c06b">concurrency_multiple</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether multiple threads can do put operations on the same queue without any further synchronization. </p>

</div>
</div>
<a class="anchor" id="a2e2bd4f332d922d3024a4bb65f9d17e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_consumes = CONSUMER_CARDINALITY == <a class="el" href="namespacedensity.html#aeef74ec0c9bea0ed2bc9802697c062cba88621d57c38a770975b5e262d557c06b">concurrency_multiple</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether multiple threads can do consume operations on the same queue without any further synchronization. </p>

</div>
</div>
<a class="anchor" id="a30744c14b0233cd7f55466ff04151aa9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool concurrent_put_consumes = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether puts and consumes can be done concurrently without any further synchronization. In any case unsynchronized concurrency is constrained by concurrent_puts and concurrent_consumes. </p>

</div>
</div>
<a class="anchor" id="a7708a88b67261ef454d875047bcfa79d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr bool is_seq_cst = true</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this queue is sequential consistent. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/density/include/density/<a class="el" href="sp__function__queue_8h_source.html">sp_function_queue.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
