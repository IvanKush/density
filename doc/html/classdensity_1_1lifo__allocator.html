<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>density: lifo_allocator&lt; UNDERLYING_ALLOCATOR, ALIGNMENT &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">density
   </div>
   <div id="projectbrief">C++11 library for paged memory management, function queues, heterogeneous queues and lifo memory management</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacedensity.html">density</a></li><li class="navelem"><a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classdensity_1_1lifo__allocator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lifo_allocator&lt; UNDERLYING_ALLOCATOR, ALIGNMENT &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="lifo_8h_source.html">lifo.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aec51b97896660342ea4809c91ca70337"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#aec51b97896660342ea4809c91ca70337">underlying_allocator</a> = UNDERLYING_ALLOCATOR</td></tr>
<tr class="separator:aec51b97896660342ea4809c91ca70337"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a697ebafbd67b0978af8e81d2734de87b"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#a697ebafbd67b0978af8e81d2734de87b">lifo_allocator</a> () noexcept</td></tr>
<tr class="separator:a697ebafbd67b0978af8e81d2734de87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0705168a3415e2498e8365c8c3faaea1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#a0705168a3415e2498e8365c8c3faaea1">lifo_allocator</a> (const UNDERLYING_ALLOCATOR &amp;i_underlying_allocator)</td></tr>
<tr class="separator:a0705168a3415e2498e8365c8c3faaea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba0287cb59cf225497d30b05a6acd3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#a92ba0287cb59cf225497d30b05a6acd3">lifo_allocator</a> (UNDERLYING_ALLOCATOR &amp;&amp;i_underlying_allocator)</td></tr>
<tr class="separator:a92ba0287cb59cf225497d30b05a6acd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a91ce514be15117efa4b77282495d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#aa9a91ce514be15117efa4b77282495d2">lifo_allocator</a> (const <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> &amp;)=delete</td></tr>
<tr class="separator:aa9a91ce514be15117efa4b77282495d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d4738f72c9a26842da2316a2a32f33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#a94d4738f72c9a26842da2316a2a32f33">operator=</a> (const <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> &amp;)=delete</td></tr>
<tr class="separator:a94d4738f72c9a26842da2316a2a32f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acced829a032ec6cce17b535e7befc327"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#acced829a032ec6cce17b535e7befc327">allocate</a> (size_t i_size)</td></tr>
<tr class="separator:acced829a032ec6cce17b535e7befc327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5535ad9f2c8a170e955bc2fe768e55d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#ad5535ad9f2c8a170e955bc2fe768e55d">allocate_empty</a> () noexcept</td></tr>
<tr class="separator:ad5535ad9f2c8a170e955bc2fe768e55d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa838620e2eb35205f72223152774eeb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#aa838620e2eb35205f72223152774eeb4">deallocate</a> (void *i_block, size_t i_size) noexcept</td></tr>
<tr class="separator:aa838620e2eb35205f72223152774eeb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84b7cb9e27cd394b8cba1f0442aeaff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#ac84b7cb9e27cd394b8cba1f0442aeaff">reallocate</a> (void *i_block, size_t i_old_size, size_t i_new_size)</td></tr>
<tr class="separator:ac84b7cb9e27cd394b8cba1f0442aeaff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c6b16bcdd69901a027b8a7ee7b41da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#ac7c6b16bcdd69901a027b8a7ee7b41da">~lifo_allocator</a> ()</td></tr>
<tr class="separator:ac7c6b16bcdd69901a027b8a7ee7b41da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad696f73ca99a680361dd50ec3d115c"><td class="memItemLeft" align="right" valign="top">UNDERLYING_ALLOCATOR &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#a8ad696f73ca99a680361dd50ec3d115c">underlying_allocator_ref</a> () noexcept</td></tr>
<tr class="separator:a8ad696f73ca99a680361dd50ec3d115c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ee86e9d4a7595254b53433ae55a8e7"><td class="memItemLeft" align="right" valign="top">const UNDERLYING_ALLOCATOR &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#ad2ee86e9d4a7595254b53433ae55a8e7">underlying_allocator_ref</a> () const  noexcept</td></tr>
<tr class="separator:ad2ee86e9d4a7595254b53433ae55a8e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac15e6b5f88a94c672b70f8a914798517"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classdensity_1_1lifo__allocator.html#ac15e6b5f88a94c672b70f8a914798517">alignment</a> = ALIGNMENT</td></tr>
<tr class="separator:ac15e6b5f88a94c672b70f8a914798517"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename UNDERLYING_ALLOCATOR = void_allocator, size_t ALIGNMENT = alignof(void*)&gt;<br />
class density::lifo_allocator&lt; UNDERLYING_ALLOCATOR, ALIGNMENT &gt;</h3>

<p>Class template that provides LIFO memory management.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">UNDERLYING_ALLOCATOR</td><td>Underlying allocator class, that can be stateless or stateful. It must meet the requirements of both <a class="el" href="UntypedAllocator_concept.html">UntypedAllocator</a> and <a class="el" href="PagedAllocator_concept.html">PagedAllocator</a>. </td></tr>
    <tr><td class="paramname">ALIGNMENT</td><td>Alignment of the blocks. It must be non-zero and a power of 2.</td></tr>
  </table>
  </dd>
</dl>
<p>A <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> uses memory pages allocated from the underlying allocator to provide lifo memory management to the user. It is designed to be efficient, so it does not provide an high-level service. All blocks has the same alignment (specified by the template argument), and the size of the requested blocks must be a multiple of it. Deallocation and reallocation functions require the caller to specify the current size of the block. Blocks that are very large according to a some implementation-defined criteria, are handled with legacy heap allocations.</p>
<p>A living block is a block allocated, eventually reallocated, but not yet deallocated. Reallocating or deallocating a block which is not the most recently allocated living block also causes undefined behavior. Instances of <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> are not interchangeable: blocks allocated by an instance can't be deallocated with another instance. All living blocks must be deallocated before the allocator is destroyed, otherwise the behavior is undefined.</p>
<p><a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> is a stateful class template (it has non-static data members). It is uncopyable, unmovable and incomparable.</p>
<p>The constructor of <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> is constexpr and guarantees constant initialization.</p>
<h2>Implementation notes </h2>
<p>A block allocation or deallocation requires only a few ALU instructions and a branch to a slow path, that is taken whenever a page switch occurs. The internal state of the allocator is composed by a pointer, that points to the next block <a class="el" href="classdensity_1_1lifo__allocator.html#acced829a032ec6cce17b535e7befc327">allocate</a> would return. A call to <a class="el" href="classdensity_1_1lifo__allocator.html#ad5535ad9f2c8a170e955bc2fe768e55d">allocate_empty</a> just return the top of the stack, without altering the state of the allocator. <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> does not cache free pages: when a page or a block is no more used, it is immediately deallocated. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="aec51b97896660342ea4809c91ca70337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classdensity_1_1lifo__allocator.html#aec51b97896660342ea4809c91ca70337">underlying_allocator</a> =  UNDERLYING_ALLOCATOR</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for the template argument UNDERLYING_ALLOCATOR </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a697ebafbd67b0978af8e81d2734de87b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor, non-throwing and suitable for constant initialization. </p>

</div>
</div>
<a class="anchor" id="a0705168a3415e2498e8365c8c3faaea1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> </td>
          <td>(</td>
          <td class="paramtype">const UNDERLYING_ALLOCATOR &amp;&#160;</td>
          <td class="paramname"><em>i_underlying_allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs passing the underlying allocator as l-value </p>

</div>
</div>
<a class="anchor" id="a92ba0287cb59cf225497d30b05a6acd3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> </td>
          <td>(</td>
          <td class="paramtype">UNDERLYING_ALLOCATOR &amp;&amp;&#160;</td>
          <td class="paramname"><em>i_underlying_allocator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs passing the underlying allocator as r-value </p>

</div>
</div>
<a class="anchor" id="aa9a91ce514be15117efa4b77282495d2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a>&lt; UNDERLYING_ALLOCATOR, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy construction not allowed </p>

</div>
</div>
<a class="anchor" id="ac7c6b16bcdd69901a027b8a7ee7b41da"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destroys the allocator, deallocating the bottom page in case this allocator is not virgin </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a94d4738f72c9a26842da2316a2a32f33"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdensity_1_1lifo__allocator.html">lifo_allocator</a>&lt; UNDERLYING_ALLOCATOR, ALIGNMENT &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment not allowed </p>

</div>
</div>
<a class="anchor" id="acced829a032ec6cce17b535e7befc327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a memory block. The content of the newly allocated memory is undefined. The new memory block is aligned at least to <a class="el" href="classdensity_1_1lifo__allocator.html#ac15e6b5f88a94c672b70f8a914798517">alignment</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_size</td><td>The size of the requested block, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>address of the allocated block</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>i_size is not a multiple of <a class="el" href="classdensity_1_1lifo__allocator.html#ac15e6b5f88a94c672b70f8a914798517">alignment</a></li>
</ul>
</dd></dl>
<p><br />
<b>Throws:</b> unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). </p>

</div>
</div>
<a class="anchor" id="ad5535ad9f2c8a170e955bc2fe768e55d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* allocate_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a block with size 0.</p>
<p>This function is equivalent to allocate(0), but it is much faster and never throws. The returned block can be reallocated and deallocated.</p>
<p>This function is useful to initialize block owners to an empty state in a noexcept context, without introducing the nullptr special case. The implementation of the default constructor of <a class="el" href="classdensity_1_1lifo__buffer.html">lifo_buffer</a> uses this function.</p>
<p><b>Throws:</b> nothing.</p>
<p><em>Implementation notes</em>: this function just returns the top of the stack, without altering the state of the allocator.</p>
<div class="fragment"><div class="line">                lifo_allocator&lt;&gt; allocator;</div><div class="line">                constexpr <span class="keyword">auto</span> <a class="code" href="classdensity_1_1lifo__allocator.html#ac15e6b5f88a94c672b70f8a914798517">alignment</a> = decltype(allocator)::alignment;</div><div class="line"></div><div class="line">                <span class="keyword">auto</span> block = allocator.allocate_empty();</div><div class="line">                assert(<a class="code" href="namespacedensity.html#abd5fec5a58abed06cfb780ff147814a7">address_is_aligned</a>(block, alignment));</div><div class="line"></div><div class="line">                block = allocator.reallocate(block, 0, alignment * 2);</div><div class="line">                assert(<a class="code" href="namespacedensity.html#abd5fec5a58abed06cfb780ff147814a7">address_is_aligned</a>(block, alignment));</div><div class="line"></div><div class="line">                allocator.deallocate(block, alignment * 2);</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa838620e2eb35205f72223152774eeb4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void deallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Deallocates the most recently allocated living memory block. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_block</td><td>The memory block to deallocate </td></tr>
    <tr><td class="paramname">i_size</td><td>Size of the block.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>the specified block is null or it is not the most recently allocated</li>
<li>the specified size is not the one asked to the most recent reallocation of the block, or to the allocation (If no reallocation was performed)</li>
</ul>
</dd></dl>
<p><br />
<b>Throws:</b> nothing. </p>

</div>
</div>
<a class="anchor" id="ac84b7cb9e27cd394b8cba1f0442aeaff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* reallocate </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>i_block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_old_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i_new_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reallocates the most recently allocated living memory block, changing its size. The address of the block may change. The content of the memory block is preserved up to the existing extend. If the memory block is moved to another address, its content is copied with memcopy. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i_block</td><td>block to be resized. After the call, if no exception is thrown, this pointer must be discarded, because it may point to invalid memory. </td></tr>
    <tr><td class="paramname">i_old_size</td><td>the previous size of the block, in bytes. </td></tr>
    <tr><td class="paramname">i_new_size</td><td>the new size requested for the block, in bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the new address of the resized block.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>The behavior is undefined if either:<ul>
<li>the specified block is null or it is not the most recently allocated</li>
<li>i_old_size is not the one asked to the most recent reallocation of the block, or to the allocation (if no reallocation was performed)</li>
<li>i_new_size is not a multiple of <a class="el" href="classdensity_1_1lifo__allocator.html#ac15e6b5f88a94c672b70f8a914798517">alignment</a></li>
</ul>
</dd></dl>
<p><br />
<b>Throws:</b> unspecified. <br />
 <b>Exception guarantee</b>: strong (in case of exception the function has no observable effects). </p>

</div>
</div>
<a class="anchor" id="a8ad696f73ca99a680361dd50ec3d115c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UNDERLYING_ALLOCATOR&amp; underlying_allocator_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a reference to the underlying allocator </p>

</div>
</div>
<a class="anchor" id="ad2ee86e9d4a7595254b53433ae55a8e7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const UNDERLYING_ALLOCATOR&amp; underlying_allocator_ref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a const reference to the underlying allocator </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ac15e6b5f88a94c672b70f8a914798517"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t alignment = ALIGNMENT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alias for the template argument ALIGNMENT </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/projects/density/density/<a class="el" href="lifo_8h_source.html">lifo.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
